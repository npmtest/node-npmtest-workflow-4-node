{"/home/travis/build/npmtest/node-npmtest-workflow-4-node/test.js":"/* istanbul instrument in package npmtest_workflow_4_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/lib.npmtest_workflow_4_node.js":"/* istanbul instrument in package npmtest_workflow_4_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_workflow_4_node = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_workflow_4_node = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-workflow-4-node && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_workflow_4_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_workflow_4_node\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_workflow_4_node.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_workflow_4_node.rollup.js'] =\n            local.assetsDict['/assets.npmtest_workflow_4_node.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_workflow_4_node.__dirname +\n                    '/lib.npmtest_workflow_4_node.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/index.js":"var es6 = true;\r\ntry {\r\n    eval(\"(() => {})()\");\r\n} catch (err) {\r\n    es6 = false;\r\n}\r\n\r\nvar es = es6 ? \"es6\" : \"es5\";\r\n\r\nif (!es6) {\r\n    require(\"babel-polyfill\");\r\n}\r\n\r\nmodule.exports = require(\"./\" + es);","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/index.js":"module.exports = {\r\n    common: require(\"./common\"),\r\n    activities: require(\"./activities\"),\r\n    hosting: require(\"./hosting\")\r\n};","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/index.js":"module.exports = {\n    enums: require(\"./enums\"),\n    errors: require(\"./errors\"),\n    asyncHelpers: require(\"./asyncHelpers\"),\n    SimpleProxy: require(\"./simpleProxy\"),\n    is: require(\"./is\"),\n    converters: require(\"./converters\")\n};","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/enums.js":"\"use strict\";\n\nmodule.exports = {\n    activityStates: {\n        run: \"run\",\n        end: \"end\",\n        complete: \"complete\",\n        cancel: \"cancel\",\n        idle: \"idle\",\n        fail: \"fail\"\n    },\n    workflowEvents: {\n        start: \"start\",\n        invoke: \"invoke\",\n        end: \"end\",\n        warn: \"warn\",\n        workflowEvent: \"workflowEvent\"\n    },\n    events: {\n        workflowEvent: \"workflowEvent\"\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/errors.js":"\"use strict\";\n\nlet util = require(\"util\");\nlet constants = require(\"./constants\");\n\nfunction ActivityStateExceptionError(message) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(ActivityStateExceptionError, Error);\n\nfunction Cancelled() {\n    ActivityStateExceptionError.call(this, \"Activity execution has been cancelled.\");\n}\n\nutil.inherits(Cancelled, ActivityStateExceptionError);\n\nfunction Idle(message) {\n    ActivityStateExceptionError.call(this, message || \"Activity is idle.\");\n}\n\nutil.inherits(Idle, ActivityStateExceptionError);\n\nfunction ActivityMarkupError(message) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(ActivityMarkupError, Error);\n\nfunction ActivityRuntimeError(message) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(ActivityRuntimeError, Error);\n\nfunction BookmarkNotFoundError(message) {\n    ActivityRuntimeError.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(BookmarkNotFoundError, ActivityRuntimeError);\n\nfunction AggregateError(errors) {\n    let message = \"\";\n    if (errors.length) {\n        message = \" First: \" + errors[0].message;\n    }\n    ActivityRuntimeError.call(this, \"Many errors occurred.\" + message);\n    this.errors = errors;\n}\n\nutil.inherits(AggregateError, ActivityRuntimeError);\n\nfunction ValidationError(message) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(ValidationError, Error);\n\nfunction TimeoutError(message) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(TimeoutError, Error);\n\nfunction WorkflowError(message) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(WorkflowError, Error);\n\nfunction MethodNotFoundError(message) {\n    WorkflowError.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(MethodNotFoundError, WorkflowError);\n\nfunction MethodIsNotAccessibleError(message) {\n    WorkflowError.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(MethodIsNotAccessibleError, WorkflowError);\n\nfunction WorkflowNotFoundError(message) {\n    WorkflowError.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n}\n\nutil.inherits(WorkflowNotFoundError, WorkflowError);\n\nmodule.exports.ActivityStateExceptionError = ActivityStateExceptionError;\nmodule.exports.ActivityExceptionError = ActivityStateExceptionError;\nmodule.exports.Cancelled = Cancelled;\nmodule.exports.Idle = Idle;\nmodule.exports.AggregateError = AggregateError;\nmodule.exports.ActivityMarkupError = ActivityMarkupError;\nmodule.exports.ActivityRuntimeError = ActivityRuntimeError;\nmodule.exports.ValidationError = ValidationError;\nmodule.exports.TimeoutError = TimeoutError;\nmodule.exports.WorkflowError = WorkflowError;\nmodule.exports.MethodNotFoundError = MethodNotFoundError;\nmodule.exports.MethodIsNotAccessibleError = MethodIsNotAccessibleError;\nmodule.exports.WorkflowNotFoundError = WorkflowNotFoundError;\nmodule.exports.BookmarkNotFoundError = BookmarkNotFoundError;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/constants.js":"\"use strict\";\n\nlet _ = require(\"lodash\");\n\nconst maxLen = \"collectingCompletedBookmark\".length;\nconst identity = \"-:\\|$WF4N$|/:-\";\n\nfunction make(name) {\n    let inner = _.snakeCase(name).toUpperCase();\n    if (inner.length > maxLen) {\n        inner = inner.substr(0, maxLen);\n    }\n    else while (inner.length < maxLen) {\n        inner += \"_\";\n    }\n    return identity + inner;\n}\n\nlet constants = {\n    identity: identity,\n    markers: {\n        valueCollectedBookmark: make(\"mValueCollectedBookmark\"),\n        collectingCompletedBookmark: make(\"mCollectingCompletedBookmark\"),\n        beginMethodBookmark: make(\"mBeginMethodBookmark\"),\n        activityProperty: make(\"mActivityProperty\"),\n        activityInstance: make(\"mActivityInstance\"),\n        keySeparator: make(\"mKeySeparator\"),\n        nope: make(\"mNope\"),\n        delayToMethodNamePrefix: make(\"mDelayToMethodNamePrefix\"),\n        $parent: make(\"mParent\")\n    },\n    ids: {\n        initialScope: make(\"mInitialScope\")\n    },\n    types: {\n        error: make(\"mError\"),\n        schedulingState: make(\"mSchedulingState\"),\n        date: make(\"mDate\"),\n        set: make(\"mSet\"),\n        map: make(\"mMap\"),\n        rex: make(\"mRex\"),\n        object: make(\"mObject\")\n    }\n};\n\nmodule.exports = constants;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/asyncHelpers.js":"var Bluebird = require(\"bluebird\");\nvar is = require(\"./is\");\n\nvar async = Bluebird.coroutine;\n\nvar asyncHelpers = {\n    async: async,\n\n    aggressiveRetry: async(function* (asyncFunc, until, timeout, timeoutError) {\n        timeoutError = timeoutError || function () {\n            return new Error(\"Retry timeout.\");\n        };\n        var startTime = new Date().getTime();\n        var waitTime = 0;\n        var waitCount = 0;\n        var result = yield asyncFunc();\n        while (!until(result)) {\n            if (new Date().getTime() - startTime > timeout) throw timeoutError();\n            yield Bluebird.delay(waitTime);\n            waitTime = Math.min(++waitCount * 250, 3000);\n            result = yield asyncFunc();\n        }\n        return result;\n    })\n}\n\nmodule.exports = asyncHelpers;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/is.js":"\"use strict\";\n\nlet _ = require(\"lodash\");\n\nlet genRegex = /^function[\\s]*\\*/;\n\nmodule.exports = {\n    activity(obj) {\n        return obj && obj instanceof require(\"../activities/activity\");\n    },\n    template(obj) {\n        return obj && obj instanceof require(\"../activities/template\");\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/simpleProxy.js":"\"use strict\";\nlet _ = require(\"lodash\");\nlet assert = require(\"better-assert\");\n\nfunction SimpleProxy(backend) {\n    assert(_.isObject(backend));\n    let self = this;\n\n    Object.defineProperty(this, \"_backend\", {\n        enumerable: false,\n        value: backend\n    });\n    Object.defineProperty(this, \"_backendKeys\", {\n        enumerable: false,\n        writable: false,\n        value: []\n    });\n    Object.defineProperty(this, \"$keys\", {\n        enumerable: false,\n        get: function () {\n            return backend.getKeys(self);\n        }\n    });\n    this.update(SimpleProxy.updateMode.init);\n}\n\nSimpleProxy.updateMode = {\n    twoWay: 0,\n    oneWay: 1,\n    init: 2\n};\n\nObject.defineProperties(SimpleProxy.prototype, {\n    _skipKeys: {\n        enumerable: false,\n        writable: false,\n        value: new Set([\"getKeys\", \"getValue\", \"setValue\"])\n    },\n    update: {\n        enumerable: false,\n        writable: false,\n        value: function(mode) {\n            let self = this;\n            if (mode === SimpleProxy.updateMode.init) {\n                for (let newKey of this._backend.getKeys(this)) {\n                    if (_.isUndefined(this[newKey])) { // This makes the list as unique\n                        this._backendKeys.push(newKey);\n                        Object.defineProperty(\n                            self,\n                            newKey,\n                            {\n                                enumerable: true,\n                                configurable: true,\n                                get: function () {\n                                    return self._backend.getValue(self, newKey);\n                                },\n                                set: function (value) {\n                                    self._backend.setValue(self, newKey, value);\n                                }\n                            }\n                        );\n                    }\n                }\n            }\n            else if (mode === SimpleProxy.updateMode.oneWay) {\n                let currBackendKeys = new Set(this._backend.getKeys(this));\n                for (let key in this) {\n                    if (!currBackendKeys.has(key)) {\n                        // new key on proxy, and not defined on backend:\n                        this._backend.setValue(self, key, this[key]);\n                        Object.defineProperty(\n                            self,\n                            key,\n                            {\n                                enumerable: true,\n                                configurable: true,\n                                get: function () {\n                                    return self._backend.getValue(self, key);\n                                },\n                                set: function (value) {\n                                    self._backend.setValue(self, key, value);\n                                }\n                            }\n                        );\n                        this._backendKeys.push(key);\n                    }\n                    else {\n                        currBackendKeys.delete(key);\n                    }\n                }\n                for (let oldKey of currBackendKeys) {\n                    delete this[oldKey];\n                }\n            }\n            else {\n                let prevBackendKeys = new Set(this._backendKeys);\n                let currBackendKeys = new Set(this._backend.getKeys(this));\n                let backedKeys = new Set();\n\n                for (let key in this) {\n                    if (!prevBackendKeys.has(key) && !currBackendKeys.has(key)) {\n                        // new key on proxy, and not defined on backend:\n                        this._backend.setValue(self, key, this[key]);\n                        Object.defineProperty(\n                            self,\n                            key,\n                            {\n                                enumerable: true,\n                                configurable: true,\n                                get: function () {\n                                    return self._backend.getValue(self, key);\n                                },\n                                set: function (value) {\n                                    self._backend.setValue(self, key, value);\n                                }\n                            }\n                        );\n                        backedKeys.add(key);\n                    }\n                }\n\n                this._backendKeys.length = 0;\n                for (let newKey of currBackendKeys) {\n                    if (!this._skipKeys.has(newKey)) {\n                        this._backendKeys.push(newKey);\n                        if (!prevBackendKeys.has(newKey) && !backedKeys.has(newKey)) {\n                            Object.defineProperty(\n                                self,\n                                newKey,\n                                {\n                                    enumerable: true,\n                                    configurable: true,\n                                    get: function () {\n                                        return self._backend.getValue(self, newKey);\n                                    },\n                                    set: function (value) {\n                                        self._backend.setValue(self, newKey, value);\n                                    }\n                                }\n                            );\n                        }\n                        else {\n                            prevBackendKeys.delete(newKey);\n                        }\n                    }\n                }\n                for (let oldKey of prevBackendKeys) {\n                    delete this[oldKey];\n                }\n            }\n        }\n    },\n    delete: {\n        enumerable: false,\n        writable: false,\n        value: function(key) {\n            delete this[key];\n            this._backend.delete(this, key);\n        }\n    }\n});\n\nmodule.exports = SimpleProxy;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/converters.js":"\"use strict\";\nlet assert = require(\"better-assert\");\nlet _ = require(\"lodash\");\n\nmodule.exports = {\n    mapToArray: function (map) {\n        if (!map) {\n            return null;\n        }\n        assert(map instanceof Map);\n        let json = [];\n        for (let kvp of map.entries()) {\n            json.push(kvp);\n        }\n        return json;\n    },\n    arrayToMap: function (json) {\n        if (!json) {\n            return null;\n        }\n        assert(_.isArray(json));\n        let map = new Map();\n        for (let kvp of json) {\n            map.set(kvp[0], kvp[1]);\n        }\n        return map;\n    },\n    setToArray: function (set) {\n        if (!set) {\n            return null;\n        }\n        assert(set instanceof Set);\n        let json = [];\n        for (let val of set.values()) {\n            json.push(val);\n        }\n        return json;\n    },\n    arrayToSet: function (json) {\n        if (!json) {\n            return null;\n        }\n        assert(_.isArray(json));\n        let set = new Set();\n        for (let val of json) {\n            set.add(val);\n        }\n        return set;\n    }\n};","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/index.js":"\"use strict\";\n\nmodule.exports = {\n    Activity: require(\"./activity\"),\n    ActivityExecutionEngine: require(\"./activityExecutionEngine\"),\n    activityMarkup: require(\"./activityMarkup\"),\n    Assign: require(\"./assign\"),\n    BeginMethod: require(\"./beginMethod\"),\n    Block: require(\"./block\"),\n    ConsoleTracker: require(\"./consoleTracker\"),\n    Declarator: require(\"./declarator\"),\n    EndMethod: require(\"./endMethod\"),\n    Expression: require(\"./expression\"),\n    Func: require(\"./func\"),\n    Parallel: require(\"./parallel\"),\n    Pick: require(\"./pick\"),\n    ResumeBookmark: require(\"./resumeBookmark\"),\n    WaitForBookmark: require(\"./waitForBookmark\"),\n    Workflow: require(\"./workflow\"),\n    If: require(\"./if\"),\n    While: require(\"./while\"),\n    Method: require(\"./method\"),\n    Composite: require(\"./composite\"),\n    Template: require(\"./template\"),\n    Thruthy: require(\"./truthy\"),\n    Falsy: require(\"./falsy\"),\n    Equals: require(\"./equals\"),\n    NotEquals: require(\"./notEquals\"),\n    Not: require(\"./not\"),\n    And: require(\"./and\"),\n    Or: require(\"./or\"),\n    For: require(\"./for\"),\n    ForEach: require(\"./forEach\"),\n    Merge: require(\"./merge\"),\n    Switch: require(\"./switch\"),\n    Case: require(\"./case\"),\n    Default: require(\"./default\"),\n    WithBody: require(\"./withBody\"),\n    When: require(\"./when\"),\n    Console: require(\"./console\"),\n    Obj: require(\"./obj\"),\n    DelayTo: require(\"./delayTo\"),\n    Delay: require(\"./delay\"),\n    Repeat: require(\"./repeat\"),\n    Try: require(\"./try\"),\n    Throw: require(\"./throw\"),\n    Emit: require(\"./emit\"),\n    Cancel: require(\"./cancel\"),\n    CancellationScope: require(\"./cancellationScope\"),\n    instanceData: require(\"./instanceData\")\n};","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/activity.js":"/*jshint -W054 */\n\n\"use strict\";\n\nlet constants = require(\"../common/constants\");\nlet errors = require(\"../common/errors\");\nlet enums = require(\"../common/enums\");\nlet _ = require(\"lodash\");\nlet specStrings = require(\"../common/specStrings\");\nlet util = require(\"util\");\nlet is = require(\"../common/is\");\nlet CallContext = require(\"./callContext\");\nlet uuid = require('node-uuid');\nlet async = require(\"../common/asyncHelpers\").async;\nlet assert = require(\"better-assert\");\nlet debug = require(\"debug\")(\"wf4node:Activity\");\nlet common = require(\"../common\");\nlet SimpleProxy = common.SimpleProxy;\n\nfunction Activity() {\n    this.args = null;\n    this.displayName = null;\n    this.id = uuid.v4();\n    this._instanceId = null;\n    this._structureInitialized = false;\n    this._scopeKeys = null;\n    this._createScopePartImpl = null;\n    this[\"@require\"] = null;\n\n    // Properties not serialized:\n    this.nonSerializedProperties = new Set();\n\n    // Properties are not going to copied in the scope:\n    this.nonScopedProperties = new Set();\n    this.nonScopedProperties.add(\"nonScopedProperties\");\n    this.nonScopedProperties.add(\"nonSerializedProperties\");\n    this.nonScopedProperties.add(\"arrayProperties\");\n    this.nonScopedProperties.add(\"activity\");\n    this.nonScopedProperties.add(\"id\");\n    this.nonScopedProperties.add(\"_instanceId\");\n    this.nonScopedProperties.add(\"args\");\n    this.nonScopedProperties.add(\"displayName\");\n    this.nonScopedProperties.add(\"complete\");\n    this.nonScopedProperties.add(\"cancel\");\n    this.nonScopedProperties.add(\"idle\");\n    this.nonScopedProperties.add(\"fail\");\n    this.nonScopedProperties.add(\"end\");\n    this.nonScopedProperties.add(\"schedule\");\n    this.nonScopedProperties.add(\"createBookmark\");\n    this.nonScopedProperties.add(\"resumeBookmark\");\n    this.nonScopedProperties.add(\"resultCollected\");\n    this.nonScopedProperties.add(\"codeProperties\");\n    this.nonScopedProperties.add(\"initializeStructure\");\n    this.nonScopedProperties.add(\"_initializeStructure\");\n    this.nonScopedProperties.add(\"_structureInitialized\");\n    this.nonScopedProperties.add(\"clone\");\n    this.nonScopedProperties.add(\"_scopeKeys\");\n    this.nonScopedProperties.add(\"_createScopePartImpl\");\n    this.nonScopedProperties.add(\"@require\");\n    this.nonScopedProperties.add(\"initializeExec\");\n    this.nonScopedProperties.add(\"unInitializeExec\");\n\n    this.codeProperties = new Set();\n    this.arrayProperties = new Set([\"args\"]);\n}\n\nObject.defineProperties(Activity.prototype, {\n    collectAll: {\n        value: true,\n        writable: false,\n        enumerable: false\n    },\n    instanceId: {\n        enumerable: false,\n        get: function() {\n            if (this._instanceId) {\n                return this._instanceId;\n            }\n            throw new errors.ActivityRuntimeError(\"Activity is not initialized in a context.\");\n        },\n        set: function(value) {\n            this._instanceId = value;\n        }\n    }\n});\n\nActivity.prototype.toString = function () {\n    return (this.displayName ? (this.displayName + \" \") : \"\") + \"(\" + this.constructor.name + \":\" + this.id + \")\";\n};\n\n/* forEach */\nActivity.prototype.all = function* (execContext) {\n    yield * this._children(true, null, execContext, null);\n};\n\nActivity.prototype.children = function* (execContext) {\n    yield * this._children(true, this, execContext, null);\n};\n\nActivity.prototype.immediateChildren = function* (execContext) {\n    yield * this._children(false, this, execContext);\n};\n\nActivity.prototype._children = function* (deep, except, execContext, visited) {\n    assert(execContext instanceof require(\"./activityExecutionContext\"), \"Cannot enumerate activities without an execution context.\");\n    visited = visited || new Set();\n    let self = this;\n    if (!visited.has(self)) {\n        visited.add(self);\n\n        // Ensure it's structure created:\n        this._initializeStructure(execContext);\n\n        if (self !== except) {\n            yield self;\n        }\n\n        for (let fieldName in self) {\n            if (self.hasOwnProperty(fieldName)) {\n                let fieldValue = self[fieldName];\n                if (fieldValue) {\n                    if (_.isArray(fieldValue)) {\n                        for (let obj of fieldValue) {\n                            if (obj instanceof Activity) {\n                                if (deep) {\n                                    yield * obj._children(deep, except, execContext, visited);\n                                }\n                                else {\n                                    yield obj;\n                                }\n                            }\n                        }\n                    }\n                    else if (fieldValue instanceof Activity) {\n                        if (deep) {\n                            yield * fieldValue._children(deep, except, execContext, visited);\n                        }\n                        else {\n                            yield fieldValue;\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n/* forEach */\n\n/* Structure */\nActivity.prototype.isArrayProperty = function (propName) {\n    return this.arrayProperties.has(propName);\n};\n\nActivity.prototype._initializeStructure = function (execContext) {\n    if (!this._structureInitialized) {\n        this.initializeStructure(execContext);\n        this._structureInitialized = true;\n    }\n};\n\nActivity.prototype.initializeStructure = _.noop;\n\nActivity.prototype.clone = function () {\n    function makeClone(value, canCloneArrays) {\n        if (value instanceof Activity) {\n            return value.clone();\n        }\n        else if (value instanceof Set) {\n            let newSet = new Set();\n            for (let item of value.values()) {\n                newSet.add(item);\n            }\n            return newSet;\n        }\n        else if (_.isArray(value)) {\n            if (canCloneArrays) {\n                let newArray = [];\n                for (let item of value) {\n                    newArray.push(makeClone(item, false));\n                }\n                return newArray;\n            }\n            else {\n                return value;\n            }\n        }\n        else {\n            return value;\n        }\n    }\n\n    let Constructor = this.constructor;\n    let newInst = new Constructor();\n    for (let key in this) {\n        if (this.hasOwnProperty(key)) {\n            let value = this[key];\n            if (newInst[key] !== value) {\n                newInst[key] = makeClone(value, true);\n            }\n        }\n    }\n    return newInst;\n};\n\n/* RUN */\nActivity.prototype.start = function (callContext) {\n    if (!(callContext instanceof CallContext)) {\n        throw new Error(\"Argument 'context' is not an instance of ActivityExecutionContext.\");\n    }\n\n    let args;\n    if (arguments.length > 1) {\n        args = [];\n        for (let i = 1; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n    }\n\n    this._start(callContext, null, args);\n};\n\nActivity.prototype._start = function (callContext, variables, args) {\n    let self = this;\n\n    if (_.isUndefined(args)) {\n        args = this.args || [];\n    }\n\n    if (!_.isArray(args)) {\n        args = [args];\n    }\n\n    let myCallContext = callContext.next(self, variables);\n    let state = myCallContext.executionState;\n    if (state.isRunning) {\n        throw new Error(\"Activity is already running.\");\n    }\n\n    // We should allow IO operations to execute:\n    setImmediate(\n        function () {\n            state.reportState(Activity.states.run, null, myCallContext.scope);\n            try {\n                self.initializeExec.call(myCallContext.scope);\n                self.run.call(myCallContext.scope, myCallContext, args);\n            }\n            catch (e) {\n                self.fail(myCallContext, e);\n            }\n        });\n};\n\nActivity.prototype.initializeExec = _.noop;\n\nActivity.prototype.unInitializeExec = _.noop;\n\nActivity.prototype.run = function (callContext, args) {\n    callContext.activity.complete(callContext, args);\n};\n\nActivity.prototype.complete = function (callContext, result) {\n    this.end(callContext, Activity.states.complete, result);\n};\n\nActivity.prototype.cancel = function (callContext) {\n    this.end(callContext, Activity.states.cancel);\n};\n\nActivity.prototype.idle = function (callContext) {\n    this.end(callContext, Activity.states.idle);\n};\n\nActivity.prototype.fail = function (callContext, e) {\n    this.end(callContext, Activity.states.fail, e);\n};\n\nActivity.prototype.end = function (callContext, reason, result) {\n    try {\n        this.unInitializeExec.call(callContext.scope, reason, result);\n    }\n    catch (e) {\n        let message = `unInitializeExec failed. Reason of ending was '${reason}' and the result is '${result}.`;\n        reason = Activity.states.fail;\n        result = e;\n    }\n\n    let state = callContext.executionState;\n\n    if (state.execState === Activity.states.cancel || state.execState === Activity.states.fail) {\n        // It was cancelled or failed:\n        return;\n    }\n\n    state.execState = reason;\n\n    let inIdle = reason === Activity.states.idle;\n    let execContext = callContext.executionContext;\n    let savedScope = callContext.scope;\n    savedScope.update(SimpleProxy.updateMode.oneWay);\n    callContext = callContext.back(inIdle);\n\n    if (callContext) {\n        try {\n            let bmName = specStrings.activities.createValueCollectedBMName(this.instanceId);\n            if (execContext.isBookmarkExists(bmName)) {\n                execContext.resumeBookmarkInScope(callContext, bmName, reason, result)\n                    .then(function() {\n                        state.emitState(result, savedScope);\n                    },\n                    function(e) {\n                        state.emitState(result, savedScope);\n                        callContext.fail(e);\n                    });\n                return;\n            }\n        }\n        catch (e) {\n            callContext.fail(e);\n        }\n    }\n    else {\n        // We're on root, done.\n        // If wf in idle, but there are internal bookmark resume request,\n        // then instead of emitting done, we have to continue them.\n        if (inIdle && execContext.processResumeBookmarkQueue()) {\n            // We should not emmit idle event, because there was internal bookmark continutations, so we're done.\n            return;\n        }\n    }\n    state.emitState(result, savedScope);\n};\n\nActivity.prototype._defaultEndCallback = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nActivity.prototype.schedule = function (callContext, obj, endCallback) {\n    let self = this;\n    let scope = callContext.scope;\n    let execContext = callContext.executionContext;\n    let selfId = callContext.instanceId;\n\n    if (!endCallback) {\n        endCallback = \"_defaultEndCallback\";\n    }\n\n    let invokeEndCallback = function (_reason, _result) {\n        setImmediate(function () {\n            scope[endCallback].call(scope, callContext, _reason, _result);\n        });\n    };\n\n    if (!_.isString(endCallback)) {\n        callContext.fail(new TypeError(\"Provided argument 'endCallback' value is not a string.\"));\n        return;\n    }\n    let cb = scope[endCallback];\n    if (!_.isFunction(cb)) {\n        callContext.fail(new TypeError(`'${endCallback}' is not a function.`));\n        return;\n    }\n\n    if (scope.__schedulingState) {\n        debug(\"%s: Error, already existsing state: %j\", selfId, scope.__schedulingState);\n        callContext.fail(new errors.ActivityStateExceptionError(\"There are already scheduled items exists.\"));\n        return;\n    }\n\n    debug(\"%s: Scheduling object(s) by using end callback '%s': %j\", selfId, endCallback, obj);\n\n    let state =\n    {\n        many: _.isArray(obj),\n        indices: new Map(),\n        results: [],\n        total: 0,\n        idleCount: 0,\n        cancelCount: 0,\n        completedCount: 0,\n        endBookmarkName: null,\n        endCallbackName: endCallback\n    };\n\n    let bookmarkNames = [];\n    try {\n        let startedAny = false;\n        let index = 0;\n        let processValue = function (value) {\n            debug(\"%s: Checking value: %j\", selfId, value);\n            let activity, variables = null;\n            if (value instanceof Activity) {\n                activity = value;\n            }\n            else if (_.isObject(value) && value.activity instanceof Activity) {\n                activity = value.activity;\n                variables = _.isObject(value.variables) ? value.variables : null;\n            }\n            if (activity) {\n                let instanceId = activity.instanceId;\n                debug(\"%s: Value is an activity with instance id: %s\", selfId, instanceId);\n                if (state.indices.has(instanceId)) {\n                    throw new errors.ActivityStateExceptionError(`Activity instance '${instanceId} has been scheduled already.`);\n                }\n                debug(\"%s: Creating end bookmark, and starting it.\", selfId);\n                bookmarkNames.push(execContext.createBookmark(selfId, specStrings.activities.createValueCollectedBMName(instanceId), \"resultCollected\"));\n                activity._start(callContext, variables);\n                startedAny = true;\n                state.indices.set(instanceId, index);\n                state.results.push(null);\n                state.total++;\n            }\n            else {\n                debug(\"%s: Value is not an activity.\", selfId);\n                state.results.push(value);\n            }\n        };\n        if (state.many) {\n            debug(\"%s: There are many values, iterating.\", selfId);\n            for (let value of obj) {\n                processValue(value);\n                index++;\n            }\n        }\n        else {\n            processValue(obj);\n        }\n        if (!startedAny) {\n            debug(\"%s: No activity has been started, calling end callback with original object.\", selfId);\n            let result = state.many ? state.results : state.results[0];\n            invokeEndCallback(Activity.states.complete, result);\n        }\n        else {\n            debug(\"%s: %d activities has been started. Registering end bookmark.\", selfId, state.indices.size);\n            let endBM = specStrings.activities.createCollectingCompletedBMName(selfId);\n            bookmarkNames.push(execContext.createBookmark(selfId, endBM, endCallback));\n            state.endBookmarkName = endBM;\n            scope.__schedulingState = state;\n        }\n        scope.update(SimpleProxy.updateMode.oneWay);\n    }\n    catch (e) {\n        debug(\"%s: Runtime error happened: %s\", selfId, e.stack);\n        if (bookmarkNames.length) {\n            debug(\"%s: Set bookmarks to noop: $j\", selfId, bookmarkNames);\n            execContext.noopCallbacks(bookmarkNames);\n        }\n        scope.delete(\"__schedulingState\");\n        debug(\"%s: Invoking end callback with the error.\", selfId);\n        invokeEndCallback(Activity.states.fail, e);\n    }\n    finally {\n        debug(\"%s: Final state indices count: %d, total: %d\", selfId, state.indices.size, state.total);\n    }\n};\n\nActivity.prototype.resultCollected = function (callContext, reason, result, bookmark) {\n    let selfId = callContext.instanceId;\n    let execContext = callContext.executionContext;\n    let childId = specStrings.getString(bookmark.name);\n    debug(\"%s: Scheduling result item collected, childId: %s, reason: %s, result: %j, bookmark: %j\", selfId, childId, reason, result, bookmark);\n\n    let finished = null;\n    let state = this.__schedulingState;\n    let fail = false;\n    try {\n        if (!_.isObject(state)) {\n            throw new errors.ActivityStateExceptionError(\"Value of __schedulingState is '\" + state + \"'.\");\n        }\n        let index = state.indices.get(childId);\n        if (_.isUndefined(index)) {\n            throw new errors.ActivityStateExceptionError(`Child activity of '${childId}' scheduling state index out of range.`);\n        }\n\n        debug(\"%s: Finished child activity id is: %s\", selfId, childId);\n\n        switch (reason) {\n            case Activity.states.complete:\n                debug(\"%s: Setting %d. value to result: %j\", selfId, index, result);\n                state.results[index] = result;\n                debug(\"%s: Removing id from state.\", selfId);\n                state.indices.delete(childId);\n                state.completedCount++;\n                break;\n            case Activity.states.fail:\n                debug(\"%s: Failed with: %s\", selfId, result.stack);\n                fail = true;\n                state.indices.delete(childId);\n                break;\n            case Activity.states.cancel:\n                debug(\"%s: Incrementing cancel counter.\", selfId);\n                state.cancelCount++;\n                debug(\"%s: Removing id from state.\", selfId);\n                state.indices.delete(childId);\n                break;\n            case Activity.states.idle:\n                debug(\"%s: Incrementing idle counter.\", selfId);\n                state.idleCount++;\n                break;\n            default:\n                throw new errors.ActivityStateExceptionError(`Result collected with unknown reason '${reason}'.`);\n        }\n\n        debug(\"%s: State so far = total: %s, indices count: %d, completed count: %d, cancel count: %d, error count: %d, idle count: %d\",\n            selfId,\n            state.total,\n            state.indices.size,\n            state.completedCount,\n            state.cancelCount,\n            state.idleCount);\n\n        let endWithNoCollectAll = !callContext.activity.collectAll && reason !== Activity.states.idle;\n        if (endWithNoCollectAll || fail) {\n            if (!fail) {\n                debug(\"%s: ---- Collecting of values ended, because we're not collecting all values (eg.: Pick).\", selfId);\n            }\n            else {\n                debug(\"%s: ---- Collecting of values ended, because of an error.\", selfId);\n            }\n            debug(\"%s: Shutting down %d other, running acitvities.\", selfId, state.indices.size);\n            let ids = [];\n            for (let id of state.indices.keys()) {\n                ids.push(id);\n                debug(\"%s: Deleting scope of activity: %s\", selfId, id);\n                execContext.deleteScopeOfActivity(callContext, id);\n                let ibmName = specStrings.activities.createValueCollectedBMName(id);\n                debug(\"%s: Deleting value collected bookmark: %s\", selfId, ibmName);\n                execContext.deleteBookmark(ibmName);\n            }\n            execContext.cancelExecution(this, ids);\n            debug(\"%s: Activities cancelled: %j\", selfId, ids);\n            debug(\"%s: Reporting the actual reason: %s and result: %j\", selfId, reason, result);\n            finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, reason, result); };\n        }\n        else {\n            assert(!fail);\n            let onEnd = (state.indices.size - state.idleCount) === 0;\n            if (onEnd) {\n                debug(\"%s: ---- Collecting of values ended (ended because of collect all is off: %s).\", selfId, endWithNoCollectAll);\n                if (state.cancelCount) {\n                    debug(\"%s: Collecting has been cancelled, resuming end bookmarks.\", selfId);\n                    finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.cancel); };\n                }\n                else if (state.idleCount) {\n                    debug(\"%s: This entry has been gone to idle, propagating counter.\", selfId);\n                    state.idleCount--; // Because the next call will wake up a thread.\n                    execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.idle);\n                }\n                else {\n                    result = state.many ? state.results : state.results[0];\n                    debug(\"%s: This entry has been completed, resuming collect bookmark with the result(s): %j\", selfId, result);\n                    finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.complete, result); };\n                }\n            }\n        }\n    }\n    catch (e) {\n        callContext.fail(e);\n        this.delete(\"__schedulingState\");\n    }\n    finally {\n        if (finished) {\n            debug(\"%s: Schduling finished, removing state.\", selfId);\n            this.delete(\"__schedulingState\");\n\n            finished();\n        }\n    }\n};\n/* RUN */\n\n/* SCOPE */\nActivity.prototype._getScopeKeys = function () {\n    let self = this;\n    if (!self._scopeKeys || !self._structureInitialized) {\n        self._scopeKeys = [];\n        for (let key in self) {\n            if (!self.nonScopedProperties.has(key) &&\n                (_.isUndefined(Activity.prototype[key]) || key === \"_defaultEndCallback\" || key === \"_subActivitiesGot\")) {\n                self._scopeKeys.push(key);\n            }\n        }\n    }\n    return self._scopeKeys;\n};\n\nActivity.prototype.createScopePart = function () {\n    if (!this._structureInitialized) {\n        throw new errors.ActivityRuntimeError(\"Cannot create activity scope for uninitialized activities.\");\n    }\n\n    if (this._createScopePartImpl === null) {\n        let first = true;\n        let src = \"return {\";\n        for (let fieldName of this._getScopeKeys()) {\n            if (first) {\n                first = false;\n            }\n            else {\n                src += \",\\n\";\n            }\n            src += fieldName + \":a.\" + fieldName;\n        }\n        src += \"}\";\n\n        try {\n            this._createScopePartImpl = new Function(\"a,_\", src);\n        }\n        catch (e) {\n            debug(\"Invalid scope part function:%s\", src);\n            throw e;\n        }\n    }\n\n    return this._createScopePartImpl(this, _);\n};\n/* SCOPE */\n\nActivity.states = enums.activityStates;\n\nmodule.exports = Activity;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/common/specStrings.js":"\"use strict\";\n\nlet constants = require(\"./constants\");\nlet _ = require(\"lodash\");\n\nlet guidLength = constants.markers.activityInstance.length;\n\nfunction makeSpecString(guid, str) {\n    return guid + \":\" + str;\n}\n\nfunction isSpecString(specString) {\n    if (_.isString(specString) && specString.length > guidLength + 1 && specString[guidLength] === \":\") {\n        let il = constants.identity.length;\n        for (let i = 0; i < il; i++) {\n            if (constants.identity[i] !== specString[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction getGuid(specString) {\n    if (!isSpecString(specString)) {\n        return null;\n    }\n    return specString.substr(0, guidLength);\n}\n\nfunction getString(specString) {\n    if (!isSpecString(specString)) {\n        return null;\n    }\n    return specString.substr(guidLength + 1);\n}\n\nfunction splitSpecString(specString) {\n    if (!isSpecString(specString)) {\n        return null;\n    }\n    return {\n        guid: specString.substr(0, guidLength),\n        str: specString.substr(guidLength + 1)\n    };\n}\n\nfunction makSpecForActivity(guid, activityId) {\n    if (!_.isString(activityId)) {\n        throw new TypeError(`Activity id '${activityId}' is not a string.`);\n    }\n    return makeSpecString(guid, activityId);\n}\n\nlet specStrings = {\n    is: isSpecString,\n    getGuid: getGuid,\n    getString: getString,\n    split: splitSpecString,\n    activities: {\n        createCollectingCompletedBMName: function (activityId) {\n            return makSpecForActivity(constants.markers.collectingCompletedBookmark, activityId);\n        },\n        createValueCollectedBMName: function (activityId) {\n            return makSpecForActivity(constants.markers.valueCollectedBookmark, activityId);\n        }\n    },\n    hosting: {\n        createBeginMethodBMName: function (methodName) {\n            return makeSpecString(constants.markers.beginMethodBookmark, methodName);\n        },\n        createDelayToMethodName: function (id) {\n            return makeSpecString(constants.markers.delayToMethodNamePrefix, id);\n        },\n        createActivityPropertyPart: function (methodName) {\n            return makeSpecString(constants.markers.activityProperty, methodName);\n        },\n        createActivityInstancePart: function (activityId) {\n            return constants.markers.activityInstance + \":\" + activityId;\n        },\n        getActivityPropertyName: function (obj) {\n            let parts = splitSpecString(obj);\n            if (parts && parts.guid === constants.markers.activityProperty) {\n                return parts.str;\n            }\n            return null;\n        },\n        getInstanceId: function (obj) {\n            let parts = splitSpecString(obj);\n            if (parts && parts.guid === constants.markers.activityInstance) {\n                return parts.str;\n            }\n            return null;\n        },\n        isDelayToMethodName: function (obj) {\n            let parts = splitSpecString(obj);\n            return parts && parts.guid === constants.markers.delayToMethodNamePrefix;\n        },\n        doubleKeys: function (key1, key2) {\n            return key1 + constants.markers.keySeparator + key2;\n        }\n    }\n}\n\nmodule.exports = specStrings;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/callContext.js":"\"use strict\";\n\nlet common = require(\"../common\");\nlet is = common.is;\nlet _ = require(\"lodash\");\n\nfunction CallContext(executionContext, activityOrActivityId, scope) {\n    this._executionContext = executionContext;\n    this._activity = activityOrActivityId ? this._asActivity(activityOrActivityId) : null;\n    this._activityInstanceId = this._activity ? this._activity.instanceId : null;\n    this._scope = scope ? scope : null;\n    this._executionState = null;\n    this._scopePart = null;\n}\n\nObject.defineProperties(\n    CallContext.prototype,\n    {\n        instanceId: {\n            get: function () {\n                return this._activityInstanceId;\n            }\n        },\n        _parentActivityId: {\n            get: function () {\n                if (!this._activity) {\n                    return null;\n                }\n                let state = this._executionContext.getExecutionState(this.instanceId);\n                return state.parentInstanceId;\n            }\n        },\n        _scopeTree: {\n            get: function () {\n                return this._executionContext._scopeTree;\n            }\n        },\n        activity: {\n            get: function () {\n                return this._activity;\n            }\n        },\n        executionContext: {\n            get: function () {\n                return this._executionContext;\n            }\n        },\n        executionState: {\n            get: function () {\n                return this._executionState || (this._activity ? (this._executionState = this._executionContext.getExecutionState(this.instanceId)) : null);\n            }\n        },\n        scope: {\n            get: function () {\n                return this._scope || (this._scope = this._scopeTree.find(this.instanceId));\n            }\n        }\n    }\n);\n\nCallContext.prototype.next = function (childActivityOrActivityId, variables) {\n    let child = this._asActivity(childActivityOrActivityId);\n    let part = child.createScopePart();\n    if (_.isObject(variables)) {\n        _.extend(part, variables);\n    }\n    return new CallContext(\n        this._executionContext,\n        child,\n        this._scopeTree.next(this.instanceId, child.instanceId, part, child.id));\n};\n\nCallContext.prototype.back = function (keepScope) {\n    let parentId = this._parentActivityId;\n    if (parentId) {\n        return new CallContext(\n            this._executionContext,\n            parentId,\n            this._scopeTree.back(this.instanceId, keepScope));\n    }\n    else {\n        return null;\n    }\n};\n\nCallContext.prototype._asActivity = function (activityOrActivityId) {\n    return is.activity(activityOrActivityId) ? activityOrActivityId : this._executionContext._getKnownActivity(activityOrActivityId);\n};\n\n/* Callbacks */\n\nCallContext.prototype.complete = function (result) {\n    this.activity.complete(this, result);\n};\n\nCallContext.prototype.cancel = function () {\n    this.activity.cancel(this);\n};\n\nCallContext.prototype.idle = function () {\n    this.activity.idle(this);\n};\n\nCallContext.prototype.fail = function (e) {\n    this.activity.fail(this, e);\n};\n\nCallContext.prototype.end = function (reason, result) {\n    this.activity.end(this, reason, result);\n};\n\nCallContext.prototype.emitWorkflowEvent = function (args) {\n    this.executionContext.emitWorkflowEvent(args);\n};\n\nCallContext.prototype.schedule = function (obj, endcallback) {\n    this.activity.schedule(this, obj, endcallback);\n};\n\nCallContext.prototype.createBookmark = function (name, callback) {\n    return this._executionContext.createBookmark(this.instanceId, name, callback);\n};\n\nCallContext.prototype.resumeBookmark = function (name, reason, result) {\n    this._executionContext.resumeBookmarkInternal(this, name, reason, result);\n};\n\nmodule.exports = CallContext;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/activityExecutionEngine.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet ActivityExecutionContext = require(\"./activityExecutionContext\");\nlet ActivityExecutionState = require(\"./activityExecutionState\");\nlet CallContext = require(\"./callContext\");\nlet EventEmitter = require('events').EventEmitter;\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\nlet _ = require(\"lodash\");\nlet ActivityStateTracker = require(\"./activityStateTracker\");\nlet enums = require(\"../common/enums\");\nlet Bluebird = require(\"bluebird\");\nlet asyncHelpers = require(\"../common/asyncHelpers\");\nlet async = asyncHelpers.async;\nlet activityMarkup = require(\"./activityMarkup\");\n\nfunction ActivityExecutionEngine(contextOrActivity, instance) {\n    EventEmitter.call(this);\n    \n    if (contextOrActivity instanceof Activity) {\n        this.rootActivity = contextOrActivity;\n        this.context = new ActivityExecutionContext(this);\n        this._isInitialized = false;\n    }\n    else if (contextOrActivity instanceof ActivityExecutionContext) {\n        this.rootActivity = contextOrActivity.rootActivity;\n        this.context = contextOrActivity;\n        this.context.engine = this;\n        this._isInitialized = true;\n    }\n    else if (_.isPlainObject(contextOrActivity)) {\n        this.rootActivity = activityMarkup.parse(contextOrActivity);\n        this.context = new ActivityExecutionContext(this);\n        this._isInitialized = false;\n    }\n    else {\n        throw new TypeError(\"Argument 'contextOrActivity' is not an activity, context or a markup.\");\n    }\n    \n    this._rootState = null;\n    this._trackers = [];\n    this._hookContext();\n    this.updatedOn = null;\n    this.instance = instance || null;\n}\n\nutil.inherits(ActivityExecutionEngine, EventEmitter);\n\nObject.defineProperties(ActivityExecutionEngine.prototype, {\n    execState: {\n        get: function () {\n            if (this._rootState) {\n                return this._rootState.execState;\n            }\n            else {\n                return null;\n            }\n        }\n    },\n    version: {\n        get: function () {\n            return this.rootActivity.version;\n        }\n    }\n});\n\nActivityExecutionEngine.prototype._idle = {\n    toString: function () {\n        return enums.activityStates.idle;\n    }\n};\n\nActivityExecutionEngine.prototype.isIdle = function (result) {\n    return result === this._idle;\n};\n\nActivityExecutionEngine.prototype._initialize = function () {\n    if (!this._isInitialized) {\n        this.context.initialize(this.rootActivity);\n        this._isInitialized = true;\n    }\n};\n\nActivityExecutionEngine.prototype._setRootState = function (state) {\n    let self = this;\n    if (!self._rootState) {\n        self._rootState = state;\n        self._rootState.on(\n            Activity.states.cancel, function (args) {\n                self.emit(Activity.states.cancel, args);\n            });\n        self._rootState.on(\n            Activity.states.complete, function (args) {\n                self.emit(Activity.states.complete, args);\n            });\n        self._rootState.on(\n            Activity.states.end, function (args) {\n                self.updatedOn = new Date();\n                self.emit(Activity.states.end, args);\n            });\n        self._rootState.on(\n            Activity.states.fail, function (args) {\n                self.emit(Activity.states.fail, args);\n            });\n        self._rootState.on(\n            Activity.states.run, function (args) {\n                self.emit(Activity.states.run, args);\n            });\n        self._rootState.on(\n            Activity.states.idle, function (args) {\n                self.emit(Activity.states.idle, args);\n            });\n    }\n};\n\nActivityExecutionEngine.prototype._hookContext = function () {\n    let self = this;\n    self.context.on(\n        Activity.states.run,\n        function (args) {\n            for (let t of self._trackers) {\n                t.activityStateChanged(args);\n            }\n        });\n    self.context.on(\n        Activity.states.end,\n        function (args) {\n            for (let t of self._trackers) {\n                t.activityStateChanged(args);\n            }\n        });\n    self.context.on(\n        enums.events.workflowEvent,\n        function(args) {\n            self.emit(enums.events.workflowEvent, args);\n        }\n    );\n};\n\nActivityExecutionEngine.prototype.addTracker = function (tracker) {\n    if (!_.isObject(tracker)) {\n        throw new TypeError(\"Parameter is not an object.\");\n    }\n    this._trackers.push(new ActivityStateTracker(tracker));\n};\n\nActivityExecutionEngine.prototype.removeTracker = function (tracker) {\n    let idx = -1;\n    for (let i = 0; i < this._trackers.length; i++) {\n        let t = this._trackers[i];\n        if (t._impl === tracker) {\n            idx = i;\n            break;\n        }\n    }\n    if (idx !== -1) {\n        this._trackers.splice(idx, 1);\n    }\n};\n\nActivityExecutionEngine.prototype.start = async(function* () {\n    this._verifyNotStarted();\n\n    this._initialize();\n\n    let args = [new CallContext(this.context)];\n    for (let a of arguments) {\n        args.push(a);\n    }\n\n    this._setRootState(yield this.rootActivity.start.apply(this.rootActivity, args));\n});\n\nActivityExecutionEngine.prototype.invoke = function () {\n    let self = this;\n\n    self._verifyNotStarted();\n\n    self._initialize();\n\n    let args = [];\n    for (let a of arguments) {\n        args.push(a);\n    }\n\n    args.unshift(new CallContext(self.context));\n\n    return new Bluebird(function (resolve, reject) {\n        try {\n            self._setRootState(self.context.getExecutionState(self.rootActivity));\n            self.once(\n                Activity.states.end, function (eArgs) {\n                    let reason = eArgs.reason;\n                    let result = eArgs.result;\n                    switch (reason) {\n                        case Activity.states.complete:\n                            resolve(result);\n                            break;\n                        case Activity.states.cancel:\n                            reject(new errors.Cancelled());\n                            break;\n                        case Activity.states.idle:\n                            resolve(self._idle);\n                            break;\n                        default :\n                            result = result || new errors.ActivityRuntimeError(\"Unknown error.\");\n                            reject(result);\n                            break;\n                    }\n                });\n\n            self.rootActivity.start.apply(self.rootActivity, args);\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n};\n\nActivityExecutionEngine.prototype._verifyNotStarted = function () {\n    if (!(!this.execState || this.execState === enums.activityStates.complete)) {\n        throw new errors.ActivityStateExceptionError(\"Workflow has been already started.\");\n    }\n};\n\nActivityExecutionEngine.prototype.resumeBookmark = function (name, reason, result) {\n    let self = this;\n    self._initialize();\n    return new Bluebird(function (resolve, reject) {\n        try {\n            self._setRootState(self.context.getExecutionState(self.rootActivity));\n\n            if (self.execState === enums.activityStates.idle) {\n                let bmTimestamp = self.context.getBookmarkTimestamp(name);\n                self.once(\n                    Activity.states.end,\n                    function (args) {\n                        let _reason = args.reason;\n                        let _result = args.result;\n                        try {\n                            if (_reason === enums.activityStates.complete || _reason === enums.activityStates.idle) {\n                                let endBmTimestamp = self.context.getBookmarkTimestamp(name);\n                                if (endBmTimestamp && endBmTimestamp === bmTimestamp) {\n                                    if (_reason === enums.activityStates.complete) {\n                                        reject(new errors.ActivityRuntimeError(\"Workflow has been completed before bookmark '\" + name + \"' reached.\"));\n                                    }\n                                    else {\n                                        reject(new errors.Idle(\"Workflow has been gone to idle before bookmark '\" + name + \"' reached.\"));\n                                    }\n                                }\n                                else {\n                                    resolve();\n                                }\n                            }\n                            else if (_reason === enums.activityStates.cancel) {\n                                reject(new errors.ActivityRuntimeError(\"Workflow has been cancelled before bookmark '\" + name + \"' reached.\"));\n                            }\n                            else if (_reason === enums.activityStates.fail) {\n                                reject(_result);\n                            }\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                self.context.resumeBookmarkExternal(name, reason, result);\n            }\n            else {\n                reject(new errors.ActivityRuntimeError(\"Cannot resume bookmark, while the workflow is not in the idle state.\"));\n            }\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n};\n\n/* SERIALIZATION */\nActivityExecutionEngine.prototype.getStateAndPromotions = function (serializer, enablePromotions) {\n    if (serializer && !_.isObject(serializer)) {\n        throw new Error(\"Argument 'serializer' is not an object.\");\n    }\n\n    this._initialize();\n    return this.context.getStateAndPromotions(serializer, enablePromotions);\n};\n\nActivityExecutionEngine.prototype.setState = function (serializer, json) {\n    if (serializer && !_.isObject(serializer)) {\n        throw new Error(\"Argument 'serializer' is not an object.\");\n    }\n    if (!_.isObject(json)) {\n        throw new TypeError(\"Argument 'json' is not an object.\");\n    }\n\n    this._initialize();\n    this.updatedOn = new Date();\n    this.context.setState(serializer, json);\n};\n/* SERIALIZATION */\n\nmodule.exports = ActivityExecutionEngine;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/activityExecutionContext.js":"\"use strict\";\n\nlet ActivityExecutionState = require(\"./activityExecutionState\");\nlet ResumeBookmarkQueue = require(\"./resumeBookmarkQueue\");\nlet enums = require(\"../common/enums\");\nlet errors = require(\"../common/errors\");\nlet util = require(\"util\");\nlet EventEmitter = require(\"events\").EventEmitter;\nlet _ = require(\"lodash\");\nlet constants = require(\"../common/constants\");\nlet ScopeTree = require(\"./scopeTree\");\nlet is = require(\"../common/is\");\nlet CallContext = require(\"./callContext\");\nlet assert = require(\"better-assert\");\nlet Bluebird = require(\"bluebird\");\nlet converters = require(\"../common/converters\");\n\nfunction ActivityExecutionContext(engine) {\n    EventEmitter.call(this);\n\n    this._activityStates = new Map();\n    this._bookmarks = new Map();\n    this._resumeBMQueue = new ResumeBookmarkQueue();\n    this.rootActivity = null;\n    this._knownActivities = new Map();\n    this._scopeTree = this._createScopeTree();\n    this.engine = engine; // Could be null in special cases, see workflowRegistry.js\n}\n\nutil.inherits(ActivityExecutionContext, EventEmitter);\n\nObject.defineProperties(\n    ActivityExecutionContext.prototype,\n    {\n        scope: {\n            get: function () {\n                return this._scopeTree.currentScope;\n            }\n        },\n        hasScope: {\n            get: function () {\n                return !this._scopeTree.isOnInitial;\n            }\n        }\n    }\n);\n\nActivityExecutionContext.prototype._createScopeTree = function () {\n    let self = this;\n    return new ScopeTree(\n        {\n            resultCollected: function (context, reason, result, bookmarkName) {\n                context.activity.resultCollected.call(context.scope, context, reason, result, bookmarkName);\n            }\n        },\n        function (id) {\n            return self._getKnownActivity(id);\n        });\n};\n\nActivityExecutionContext.prototype.initialize = function (rootActivity) {\n    if (this.rootActivity) {\n        throw new Error(\"Context is already initialized.\");\n    }\n    if (!is.activity(rootActivity)) {\n        throw new TypeError(\"Argument 'rootActivity' value is not an activity.\");\n    }\n\n    this.rootActivity = rootActivity;\n    this._initialize(null, rootActivity, { instanceId: 0 });\n};\n\nActivityExecutionContext.prototype._checkInit = function () {\n    if (!this.rootActivity) {\n        throw new Error(\"Context is not initialized.\");\n    }\n};\n\nActivityExecutionContext.prototype._initialize = function (parent, activity, idCounter) {\n    let activityId = activity._instanceId;\n    let nextId = (idCounter.instanceId++).toString();\n    if (!activityId) {\n        activityId = nextId;\n        activity.instanceId = activityId;\n    }\n    else if (activityId !== nextId) {\n        throw new errors.ActivityRuntimeError(\"Activity \" + activity + \" has been assigned to an other position.\");\n    }\n\n    let state = this.getExecutionState(activityId);\n    state.parentInstanceId = parent ? parent.instanceId : null;\n    this._knownActivities.set(activityId, activity);\n\n    for (let child of activity.immediateChildren(this)) {\n        this._initialize(activity, child, idCounter);\n        state.childInstanceIds.add(child.instanceId);\n    }\n};\n\nActivityExecutionContext.prototype.getExecutionState = function (idOrActivity) {\n    let self = this;\n\n    let id;\n    if (_.isString(idOrActivity)) {\n        id = idOrActivity;\n    }\n    else if (is.activity(idOrActivity)) {\n        id = idOrActivity.instanceId;\n    }\n    else {\n        throw new TypeError(\"Cannot get state of \" + idOrActivity);\n    }\n    let state = self._activityStates.get(id);\n    if (_.isUndefined(state)) {\n        state = new ActivityExecutionState(id);\n        state.on(\n            enums.activityStates.run,\n            function (args) {\n                self.emit(enums.activityStates.run, args);\n            });\n        state.on(\n            enums.activityStates.end,\n            function (args) {\n                self.emit(enums.activityStates.end, args);\n            });\n        self._activityStates.set(id, state);\n    }\n    return state;\n};\n\nActivityExecutionContext.prototype._getKnownActivity = function (activityId) {\n    let activity = this._knownActivities.get(activityId);\n    if (!activity) {\n        throw new errors.ActivityRuntimeError(\"Activity by id '\" + activityId + \"' not found.\");\n    }\n    return activity;\n};\n\nActivityExecutionContext.prototype.createBookmark = function (activityId, name, endCallback) {\n    this.registerBookmark(\n        {\n            name: name,\n            instanceId: activityId,\n            timestamp: new Date().getTime(),\n            endCallback: endCallback\n        });\n    return name;\n};\n\nActivityExecutionContext.prototype.registerBookmark = function (bookmark) {\n    let bm = this._bookmarks.get(bookmark.name);\n    if (bm) {\n        throw new errors.ActivityRuntimeError(\"Bookmark '\" + bookmark.name + \"' already exists.\");\n    }\n    this._bookmarks.set(bookmark.name, bookmark);\n};\n\nActivityExecutionContext.prototype.isBookmarkExists = function (name) {\n    return this._bookmarks.has(name);\n};\n\nActivityExecutionContext.prototype.getBookmarkTimestamp = function (name, throwIfNotFound) {\n    let bm = this._bookmarks.get(name);\n    if (_.isUndefined(bm) && throwIfNotFound) {\n        throw new Error(\"Bookmark '\" + name + \"' not found.\");\n    }\n    return bm ? bm.timestamp : null;\n};\n\nActivityExecutionContext.prototype.deleteBookmark = function (name) {\n    this._bookmarks.delete(name);\n};\n\nActivityExecutionContext.prototype.noopCallbacks = function (bookmarkNames) {\n    for (let name of bookmarkNames) {\n        let bm = this._bookmarks.get(name);\n        if (bm) {\n            bm.endCallback = _.noop;\n        }\n    }\n};\n\nActivityExecutionContext.prototype.resumeBookmarkInScope = function (callContext, name, reason, result) {\n    let bm = this._bookmarks.get(name);\n    if (_.isUndefined(bm)) {\n        throw new Error(\"Bookmark '\" + name + \"' doesn't exists. Cannot continue with reason: \" + reason + \".\");\n    }\n    let self = this;\n    return new Bluebird(function (resolve, reject) {\n        setImmediate(function () {\n            try {\n                bm = self._bookmarks.get(name);\n                if (bm) {\n                    // If bm is still exists.\n                    self._doResumeBookmark(callContext, bm, reason, result, reason === enums.activityStates.idle);\n                    resolve(true);\n                }\n                resolve(false);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    });\n};\n\nActivityExecutionContext.prototype.resumeBookmarkInternal = function (callContext, name, reason, result) {\n    let bm = this._bookmarks.get(name);\n    this._resumeBMQueue.enqueue(name, reason, result);\n};\n\nActivityExecutionContext.prototype.resumeBookmarkExternal = function (name, reason, result) {\n    let self = this;\n    let bm = self._bookmarks.get(name);\n    if (!bm) {\n        throw new errors.BookmarkNotFoundError(\"Internal resume bookmark request cannot be processed because bookmark '\" + name + \"' doesn't exists.\");\n    }\n    self._doResumeBookmark(new CallContext(this, bm.instanceId), bm, reason, result);\n};\n\nActivityExecutionContext.prototype.processResumeBookmarkQueue = function () {\n    let self = this;\n    let command = self._resumeBMQueue.dequeue();\n    if (command) {\n        let bm = self._bookmarks.get(command.name);\n        if (!bm) {\n            throw new errors.BookmarkNotFoundError(\"Internal resume bookmark request cannot be processed because bookmark '\" + command.name + \"' doesn't exists.\");\n        }\n        self._doResumeBookmark(new CallContext(this, bm.instanceId), bm, command.reason, command.result);\n        return true;\n    }\n    return false;\n};\n\nActivityExecutionContext.prototype._doResumeBookmark = function (callContext, bookmark, reason, result, noRemove) {\n    let scope = callContext.scope;\n    if (!noRemove) {\n        this._bookmarks.delete(bookmark.name);\n    }\n    let cb = bookmark.endCallback;\n    if (_.isString(cb)) {\n        cb = scope[bookmark.endCallback];\n        if (!_.isFunction(cb)) {\n            cb = null;\n        }\n    }\n\n    if (!cb) {\n        throw new errors.ActivityRuntimeError(\"Bookmark's '\" + bookmark.name + \"' callback '\" + bookmark.endCallback + \"' is not defined on the current scope.\");\n    }\n\n    // TODO: if it fails, resume on default callback with the error!\n    cb.call(scope, callContext, reason, result, bookmark);\n};\n\nActivityExecutionContext.prototype.cancelExecution = function (scope, activityIds) {\n    let self = this;\n    let allIds = new Set();\n    for (let id of activityIds) {\n        self._cancelSubtree(scope, allIds, id);\n    }\n    for (let bm of self._bookmarks.values()) {\n        if (allIds.has(bm.instanceId)) {\n            self._bookmarks.delete(bm.name);\n        }\n    }\n};\n\nActivityExecutionContext.prototype._cancelSubtree = function (scope, allIds, activityId) {\n    let self = this;\n    allIds.add(activityId);\n    let state = self.getExecutionState(activityId);\n    for (let id of state.childInstanceIds.values()) {\n        self._cancelSubtree(scope, allIds, id);\n    }\n    state.reportState(enums.activityStates.cancel, null, scope);\n};\n\nActivityExecutionContext.prototype.deleteScopeOfActivity = function (callContext, activityId) {\n    this._scopeTree.deleteScopePart(callContext.instanceId, activityId);\n};\n\nActivityExecutionContext.prototype.emitWorkflowEvent = function (args) {\n    this.emit(enums.events.workflowEvent, args);\n};\n\n/* SERIALIZATION */\n\nActivityExecutionContext.prototype.getStateAndPromotions = function (serializer, enablePromotions) {\n    if (serializer && !_.isFunction(serializer.toJSON)) {\n        throw new TypeError(\"Argument 'serializer' is not a serializer.\");\n    }\n\n    let activityStates = new Map();\n    for (let s of this._activityStates.values()) {\n        activityStates.set(s.instanceId, s.asJSON());\n    }\n\n    let scopeStateAndPromotions = this._scopeTree.getExecutionState(this, enablePromotions, serializer);\n\n    let serialized;\n    if (serializer) {\n        serialized = serializer.toJSON({\n            activityStates: activityStates,\n            bookmarks: this._bookmarks,\n            scope: scopeStateAndPromotions.state\n        });\n    }\n    else {\n        serialized = {\n            activityStates: converters.mapToArray(activityStates),\n            bookmarks: converters.mapToArray(this._bookmarks),\n            scope: scopeStateAndPromotions.state\n        };\n    }\n\n    return {\n        state: serialized,\n        promotedProperties: scopeStateAndPromotions.promotedProperties\n    };\n};\n\nActivityExecutionContext.prototype.setState = function (serializer, json) {\n    if (serializer && !_.isFunction(serializer.fromJSON)) {\n        throw new TypeError(\"Argument 'serializer' is not a serializer.\");\n    }\n    if (!_.isObject(json)) {\n        throw new TypeError(\"Argument 'json' is not an object.\");\n    }\n\n    if (serializer) {\n        json = serializer.fromJSON(json);\n        if (!(json.activityStates instanceof Map)) {\n            throw new TypeError(\"activityStates property value of argument 'json' is not an Map instance.\");\n        }\n        if (!(json.bookmarks instanceof Map)) {\n            throw new TypeError(\"Bookmarks property value of argument 'json' is not an Map instance.\");\n        }\n    }\n    else {\n        if (!json.activityStates) {\n            throw new TypeError(\"activityStates property value of argument 'json' is not an object.\");\n        }\n        if (!json.bookmarks) {\n            throw new TypeError(\"Bookmarks property value of argument 'json' is not an object.\");\n        }\n\n        json = {\n            activityStates: converters.arrayToMap(json.activityStates),\n            bookmarks: converters.arrayToMap(json.bookmarks),\n            scope: json.scope\n        };\n    }\n\n    for (let s of this._activityStates.values()) {\n        let stored = json.activityStates.get(s.instanceId);\n        if (_.isUndefined(stored)) {\n            throw new Error(\"Activity's of '\" + s.instanceId + \"' state not found.\");\n        }\n        s.fromJSON(stored);\n    }\n\n    this._bookmarks = json.bookmarks;\n    this._scopeTree.setState(json.scope, serializer);\n};\n/* SERIALIZATION */\n\nmodule.exports = ActivityExecutionContext;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/activityExecutionState.js":"\"use strict\";\n\nlet EventEmitter = require('events').EventEmitter;\nlet util = require(\"util\");\nlet enums = require(\"../common/enums\");\nlet is = require(\"../common/is\");\nlet _ = require(\"lodash\");\n\nfunction ActivityExecutionState(activityInstanceId) {\n    this.instanceId = activityInstanceId;\n    this.execState = null;\n    this.parentInstanceId = null;\n    this.childInstanceIds = new Set();\n}\n\nutil.inherits(ActivityExecutionState, EventEmitter);\n\nObject.defineProperties(ActivityExecutionState.prototype, {\n    isRunning: {\n        get: function () {\n            return this.execState === enums.activityStates.run;\n        }\n    }\n});\n\nActivityExecutionState.prototype.reportState = function (reason, result, scope) {\n    if (this.execState !== reason) {\n        this.execState = reason;\n        this._emitState({\n            reason: reason,\n            result: result,\n            scope: scope\n        });\n    }\n};\n\nActivityExecutionState.prototype.emitState = function (result, scope) {\n    this._emitState({\n        reason: this.execState,\n        result: result,\n        scope: scope\n    });\n};\n\nActivityExecutionState.prototype._emitState = function (args) {\n    this.emit(args.reason, args);\n    if (args.reason !== enums.activityStates.run) {\n        this.emit(enums.activityStates.end, args);\n    }\n};\n\n/* SERIALIZATION */\nActivityExecutionState.prototype.asJSON = function () {\n    return {\n        execState: this.execState\n    };\n};\n\nActivityExecutionState.prototype.fromJSON = function (json) {\n    if (!_.isObject(json)) {\n        throw new TypeError(\"Object argument expected.\");\n    }\n    if (json.execState !== null) {\n        if (!_.isString(json.execState)) {\n            throw new TypeError(\"Argument object's execState property value is not a string.\");\n        }\n        if (_.isUndefined(enums.activityStates[json.execState])) {\n            throw new TypeError(\"Argument object's execState property value is not a valid Activity state value.\");\n        }\n    }\n\n    this.execState = json.execState;\n};\n/* SERIALIZATION */\n\nmodule.exports = ActivityExecutionState;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/resumeBookmarkQueue.js":"\"use strict\";\n\nlet errors = require(\"../common/errors\");\n\nfunction ResumeBookmarkQueue() {\n    this._names = new Set();\n    this._commands = [];\n}\n\nResumeBookmarkQueue.prototype.isEmpty = function () {\n    return this._commands.length === 0;\n};\n\nResumeBookmarkQueue.prototype.enqueue = function (bookmarkName, reason, result) {\n    if (!this._names.has(bookmarkName)) {\n        this._names.add(bookmarkName);\n        this._commands.push(\n            {\n                name: bookmarkName,\n                reason: reason,\n                result: result\n            });\n    }\n    else {\n        throw new errors.ActivityRuntimeError(\"The '\" + bookmarkName + \"' bookmark continuation already enqueued.\");\n    }\n};\n\nResumeBookmarkQueue.prototype.dequeue = function () {\n    if (this._commands.length) {\n        let command = this._commands[0];\n        this._commands.splice(0, 1);\n        this._names.delete(command.name);\n        return command;\n    }\n    return null;\n};\n\nResumeBookmarkQueue.prototype.remove = function (bookmarkName) {\n    if (this._names.has(bookmarkName)) {\n        let idx = -1;\n        for (let i = 0; i < this._commands.length; i++) {\n            let command = this._commands[i];\n            if (command.name === bookmarkName) {\n                idx = i;\n                break;\n            }\n        }\n        if (idx !== -1) {\n            this._commands.splice(idx, 1);\n        }\n        this._names.delete(bookmarkName);\n    }\n};\n\nmodule.exports = ResumeBookmarkQueue;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/scopeTree.js":"\"use strict\";\n\nlet ScopeNode = require(\"./scopeNode\");\nlet constants = require(\"../common/constants\");\nlet _ = require(\"lodash\");\nlet specStrings = require(\"../common/specStrings\");\nlet errors = require(\"../common/errors\");\nlet is = require(\"../common/is\");\nlet scope = require(\"./scope\");\nlet Expression = require(\"./expression\");\nlet scopeSerializer = require(\"./scopeSerializer\");\n\nfunction ScopeTree(initialScope, getActivityByIdFunc) {\n    this._initialNode = new ScopeNode(constants.ids.initialScope, initialScope);\n    this._nodes = new Map();\n    this._nodes.set(this._initialNode.instanceId, this._initialNode);\n    this._getActivityById = getActivityByIdFunc;\n}\n\n/* SERIALIZATION */\nScopeTree.prototype.getExecutionState = function (execContext, enablePromotions, serializer) {\n    return scopeSerializer.serialize(execContext, this._getActivityById, enablePromotions, this._nodes.values(), serializer);\n};\n\nScopeTree.prototype.setState = function (json, serializer) {\n    if (!_.isArray(json)) {\n        throw new TypeError(\"Array argument expected.\");\n    }\n\n    if (this._nodes.count !== 1) {\n        let prev = this._nodes;\n        this._nodes = new Map();\n        this._nodes.set(constants.ids.initialScope, prev.get(constants.ids.initialScope));\n        this._initialNode.clearChildren();\n    }\n\n    try {\n        // Create nodes:\n        for (let node of scopeSerializer.deserializeNodes(this._getActivityById, json, serializer)) {\n            this._nodes.set(node.instanceId, node);\n        }\n        // Setup Tree:\n        for (let item of json) {\n            this._nodes.get(item.instanceId).parent = this._nodes.get(item.parentId);\n        }\n        // Setup specials:\n        for (let node of this._nodes.values()) {\n            for (let key of node._keys) {\n                let value = node.scopePart[key];\n                if (value && value.$type === constants.markers.$parent) {\n                    let parentScope = scope.create(this, this._nodes.get(value.id), true);\n                    parentScope.__marker = constants.markers.$parent;\n                    node.scopePart[key] = parentScope;\n                }\n            }\n        }\n    }\n    catch (e) {\n        throw new errors.WorkflowError(\"Cannot restore state tree, because data is corrupt. Inner error: \" + e.stack);\n    }\n};\n/* SERIALIZATION */\n\n/* PROXY */\n\nScopeTree.prototype._getRealParent = function (currentNode) {\n    let parent = currentNode.parent;\n    if (currentNode.activity instanceof Expression) {\n        parent = parent.parent;\n    }\n    return parent;\n};\n\nScopeTree.prototype.hasProperty = function (currentNode, name) {\n    if (name === \"$parent\") {\n        let parent = this._getRealParent(currentNode);\n        if (parent && parent !== this._initialNode) {\n            return !!parent;\n        }\n    }\n\n    if (name === \"$activity\") {\n        return true;\n    }\n\n    let found = false;\n    for (let node of currentNode.walkToRoot()) {\n        if (node.isPropertyExists(name)) {\n            found = true;\n            break;\n        }\n        if (node.userId === name) {\n            found = true;\n            break;\n        }\n    }\n    return found;\n};\n\nScopeTree.prototype.getValue = function (currentNode, name) {\n    let self = this;\n\n    if (name === \"$parent\") {\n        let parent = this._getRealParent(currentNode);\n        if (parent && parent !== this._initialNode) {\n            let parentScope = scope.create(this, parent);\n            parentScope.__marker = constants.markers.$parent;\n            return parentScope;\n        }\n        else {\n            return undefined;\n        }\n    }\n\n    if (name === \"$activity\") {\n        return currentNode.activity;\n    }\n\n    let canReturnPrivate = true;\n    let value;\n    for (let node of currentNode.walkToRoot()) {\n        if (!_.isUndefined(value = node.getPropertyValue(name, canReturnPrivate))) {\n            break;\n        }\n        if (node.userId === name && node !== currentNode) {\n            value = scope.create(self, node);\n            break;\n        }\n        canReturnPrivate = false;\n    }\n    return value;\n};\n\nScopeTree.prototype.setValue = function (currentNode, name, value, noWalk) {\n    if (this.isOnInitial) {\n        throw new Error(\"Cannot set property of the initial scope.\");\n    }\n\n    let self = this;\n    let canSetPrivate = true;\n    let setDone = false;\n    for (let node of currentNode.walkToRoot(noWalk)) {\n        if (node === self._initialNode) {\n            break;\n        }\n        if (node.setPropertyValue(name, value, canSetPrivate)) {\n            setDone = true;\n            break;\n        }\n        canSetPrivate = false;\n    }\n\n    if (!setDone) {\n        currentNode.createPropertyWithValue(name, value);\n    }\n\n    return true;\n};\n\nScopeTree.prototype.deleteProperty = function (currentNode, name, noWalk) {\n    let self = this;\n    let canDeletePrivate = true;\n    let deleteDone = false;\n    for (let node of currentNode.walkToRoot(noWalk)) {\n        if (node === self._initialNode) {\n            break;\n        }\n        if (node.deleteProperty(name, canDeletePrivate)) {\n            deleteDone = true;\n            break;\n        }\n        canDeletePrivate = false;\n    }\n\n    return deleteDone;\n};\n\nScopeTree.prototype.enumeratePropertyNames = function* (currentNode, noWalk) {\n    let canEnumeratePrivate = true;\n    let node = currentNode;\n    do\n    {\n        yield \"$parent\";\n        yield \"$activity\";\n        if (node.userId) {\n            yield node.userId;\n        }\n        yield* node.enumeratePropertyNames(canEnumeratePrivate);\n        canEnumeratePrivate = false;\n\n        if (noWalk) {\n            break;\n        }\n\n        node = node.parent;\n    }\n    while (node);\n};\n/* PROXY */\n\n/* WALK */\nScopeTree.prototype.next = function (nodeInstanceId, childInstanceId, scopePart, childUserId) {\n    let currentNode = this._getNodeByExternalId(nodeInstanceId);\n    let nextNode = new ScopeNode(childInstanceId, scopePart, childUserId, this._getActivityById(childInstanceId));\n    currentNode.addChild(nextNode);\n    this._nodes.set(childInstanceId, nextNode);\n    return scope.create(this, nextNode);\n};\n\nScopeTree.prototype.back = function (nodeId, keepItem) {\n    let currentNode = this._getNodeByExternalId(nodeId);\n    if (currentNode === this._initialNode) {\n        throw new Error(\"Cannot go back because current scope is the initial scope.\");\n    }\n    let toRemove = currentNode;\n    let goTo = toRemove.parent;\n    currentNode = goTo;\n    if (!keepItem) {\n        goTo.removeChild(toRemove);\n        this._nodes.delete(toRemove.instanceId);\n    }\n    return scope.create(this, currentNode);\n};\n\nScopeTree.prototype.find = function (nodeId) {\n    let currentNode = this._getNodeByExternalId(nodeId);\n    return scope.create(this, currentNode);\n};\n\nScopeTree.prototype.findPart = function (nodeId) {\n    let currentNode = this._getNodeByExternalId(nodeId);\n    if (currentNode !== this._initialNode) {\n        return currentNode.scopePart;\n    }\n    return null;\n};\n/* WALK */\n\nScopeTree.prototype._getNodeByExternalId = function (id) {\n    if (id === null) {\n        return this._initialNode;\n    }\n    let node = this._nodes.get(id);\n    if (!node) {\n        throw new Error(\"Scope node for activity id '\" + id + \"' is not found.\");\n    }\n    return node;\n};\n\nScopeTree.prototype.deleteScopePart = function (currentNodeId, id) {\n    let self = this;\n    let currentNode = this._getNodeByExternalId(currentNodeId);\n    let delNode = self._nodes.get(id);\n    if (delNode) {\n        if (delNode === self._initialNode) {\n            throw new Error(\"Cannot delete the initial scope.\");\n        }\n        let found = false;\n        for (let node of delNode.walkToRoot()) {\n            if (node === currentNode) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error(\"Cannot delete scope, because current active scope is inside in it.\");\n        }\n        delNode.parent.removeChild(delNode);\n        self._removeAllNodes(delNode);\n    }\n};\n\nScopeTree.prototype._removeAllNodes = function (node) {\n    let self = this;\n\n    self._nodes.delete(node.instanceId);\n    for (let c of node.children()) {\n        self._removeAllNodes(c);\n    }\n};\n\nmodule.exports = ScopeTree;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/scopeNode.js":"\"use strict\";\n\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet is = require(\"../common/is\");\nlet assert = require(\"assert\");\n\nfunction ScopeNode(instanceId, scopePart, userId, activity) {\n    assert(instanceId);\n    assert(scopePart);\n    this.instanceId = instanceId;\n    this.userId = userId;\n    this.activity = activity || null;\n    this._parent = null;\n    this._children = new Map();\n    this._scopePart = scopePart;\n    this._keys = [];\n    for (let key in scopePart) {\n        this._keys.push(key);\n    }\n}\n\nObject.defineProperties(ScopeNode.prototype, {\n    _keys: {\n        value: null,\n        writable: true,\n        enumerable: false\n    },\n    scopePart: {\n        get: function() {\n            return this._scopePart;\n        }\n    },\n    parent: {\n        get: function () {\n            return this._parent;\n        },\n        set: function (value) {\n            if (value !== null && !(value instanceof ScopeNode)) {\n                throw new TypeError(\"Node argument expected.\");\n            }\n            if (this._parent !== null) {\n                throw new Error(\"Parent already defined.\");\n            }\n            value.addChild(this);\n        }\n    }\n});\n\nScopeNode.prototype.walkToRoot = function* () {\n    let current = this;\n    while (current) {\n        yield current;\n        current = current._parent;\n    }\n};\n\nScopeNode.prototype.children = function* () {\n    for (let child of this._children.values()) {\n        yield child;\n    }\n};\n\nScopeNode.prototype.addChild = function (childItem) {\n    if (!(childItem instanceof ScopeNode)) {\n        throw new TypeError(\"Node argument expected.\");\n    }\n    if (childItem._parent) {\n        throw new Error(\"Item has been already ha a parent node.\");\n    }\n    childItem._parent = this;\n    this._children.set(childItem.instanceId, childItem);\n};\n\nScopeNode.prototype.removeChild = function (childItem) {\n    if (!(childItem instanceof ScopeNode)) {\n        throw new TypeError(\"Node argument expected.\");\n    }\n    if (childItem._parent !== this) {\n        throw new Error(\"Item is not a current node's child.\");\n    }\n    childItem._parent = null;\n    this._children.delete(childItem.instanceId);\n};\n\nScopeNode.prototype.clearChildren = function () {\n    this._children.clear();\n};\n\nScopeNode.prototype.isPropertyExists = function (name) {\n    return !_.isUndefined(this._scopePart[name]);\n};\n\nScopeNode.prototype.getPropertyValue = function (name, canReturnPrivate) {\n    if (canReturnPrivate) {\n        return this._scopePart[name];\n    }\n    else if (!this._isPrivate(name)) {\n        return this._scopePart[name];\n    }\n};\n\nScopeNode.prototype.setPropertyValue = function (name, value, canSetPrivate) {\n    if (this._isPrivate(name)) {\n        if (canSetPrivate) {\n            if (!this.isPropertyExists(name)) {\n                this._keys.push(name);\n            }\n            this._scopePart[name] = value;\n            return true;\n        }\n    }\n    else if (!_.isUndefined(this._scopePart[name])) {\n        this._scopePart[name] = value;\n        return true;\n    }\n    return false;\n};\n\nScopeNode.prototype.createPropertyWithValue = function (name, value) {\n    if (!this.isPropertyExists(name)) {\n        this._keys.push(name);\n    }\n    this._scopePart[name] = value;\n};\n\nScopeNode.prototype.deleteProperty = function (name, canDeletePrivate) {\n    if (!_.isUndefined(this._scopePart[name])) {\n        if (this._isPrivate(name)) {\n            if (canDeletePrivate) {\n                this._keys.splice(_.indexOf(this._keys, name), 1);\n                delete this._scopePart[name];\n                return true;\n            }\n        }\n        else {\n            this._keys.splice(_.indexOf(this._keys, name), 1);\n            delete this._scopePart[name];\n            return true;\n        }\n    }\n    return false;\n};\n\nScopeNode.prototype.enumeratePropertyNames = function* (canEnumeratePrivate) {\n    if (canEnumeratePrivate) {\n        for (let i = 0; i < this._keys.length; i++) {\n            yield this._keys[i];\n        }\n    }\n    else {\n        for (let i = 0; i < this._keys.length; i++) {\n            let key = this._keys[i];\n            if (!this._isPrivate(key)) {\n                yield key;\n            }\n        }\n    }\n};\n\nScopeNode.prototype.properties = function* () {\n    let self = this;\n    for (let fn of self._keys) {\n        yield { name: fn, value: self._scopePart[fn] };\n    }\n};\n\nScopeNode.prototype._isPrivate = function (key) {\n    return key[0] === \"_\";\n};\n\nmodule.exports = ScopeNode;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/scope.js":"\"use strict\";\n\nlet _ = require(\"lodash\");\n\nlet scopeFactory = {\n    create: function(scopeTree, node) {\n        let Proxy;\n        try {\n            Proxy = require(\"node-proxy\");\n        }\n        catch(e) {\n            _.noop(e);\n        }\n        if (Proxy) {\n            // node-proxy is successfully compiled and loadded\n            return Proxy.create({\n                has: function (name) {\n                    return scopeTree.hasProperty(node, name);\n                },\n\n                get: function (target, name) {\n                    if (name === \"$keys\") {\n                        return scopeTree.enumeratePropertyNames(node);\n                    }\n                    else if (name === \"delete\") {\n                        return this.delete;\n                    }\n                    else if (name === \"update\") {\n                        return _.noop;\n                    }\n                    return scopeTree.getValue(node, name);\n                },\n\n                set: function (target, name, value) {\n                    if (name === \"$keys\" || name === \"delete\" || name === \"update\") {\n                        throw new TypeError(`${name} is read only.`);\n                    }\n                    scopeTree.setValue(node, name, value);\n                    return value;\n                },\n\n                delete: function (name) {\n                    return scopeTree.deleteProperty(node, name);\n                },\n\n                enumerate: function (target) {\n                    return scopeTree.enumeratePropertyNames(node);\n                }\n            });\n        }\n        else {\n            // node-proxy is unavailable, we should emulate a proxy:\n            let SimpleProxy = require(\"../common/simpleProxy\");\n\n            let getKeys = function() {\n                let keys = [];\n                let has = new Set();\n                for (let key of scopeTree.enumeratePropertyNames(node)) {\n                    if (!has.has(key)) {\n                        keys.push(key);\n                        has.add(key);\n                    }\n                }\n                return keys;\n            };\n\n            return new SimpleProxy({\n                getKeys: function (proxy) {\n                    return getKeys();\n                },\n                getValue: function (proxy, name) {\n                    return scopeTree.getValue(node, name);\n                },\n                setValue: function (proxy, name, value) {\n                    scopeTree.setValue(node, name, value);\n                    return value;\n                },\n                delete: function (proxy, name) {\n                    scopeTree.deleteProperty(node, name);\n                }\n            });\n        }\n    }\n};\n\nmodule.exports = scopeFactory;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/expression.js":"/* jshint -W054*/\n\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet errors = require(\"../common/errors\");\n\nfunction Expression(expr) {\n    Activity.call(this);\n    this.expr = expr || null;\n    this.nonSerializedProperties.add(\"_f\");\n}\n\nutil.inherits(Expression, Activity);\n\nExpression.prototype.run = function (callContext, args) {\n    let self = this;\n    let expr = self.expr;\n    if (expr) {\n        try {\n            let f = self._f;\n            if (!f) {\n                f = self._f = new Function(\"_\", \"return (\" + expr + \")\");\n            }\n            let result = f.call(self, _);\n            if (result === callContext.activity) {\n                let parent = this.$parent;\n                if (!parent) {\n                    callContext.fail(new errors.ActivityRuntimeError(\"Exception can't reference itself.\"));\n                    return;\n                }\n                result = f.call(parent, _);\n            }\n            callContext.complete(result);\n        }\n        catch(e) {\n            callContext.fail(e);\n        }\n    }\n    else {\n        callContext.complete(null);\n    }\n};\n\nmodule.exports = Expression;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/scopeSerializer.js":"\"use strict\";\nlet constants = require(\"../common/constants\");\nlet specStrings = require(\"../common/specStrings\");\nlet _ = require(\"lodash\");\nlet is = require(\"../common/is\");\nlet ScopeNode = require(\"./scopeNode\");\nlet errors = require(\"../common/errors\");\nlet converters = require(\"../common/converters\");\nlet Serializer = require(\"backpack-node\").system.Serializer;\n\nlet arrayHandler = {\n    serialize: function (serializer, activity, execContext, getActivityById, propName, propValue, result) {\n        let ser = null;\n        if (!serializer) {\n            ser = new Serializer(); // It should get serialized internally.\n        }\n        if (_.isArray(propValue)) {\n            let stuff = [];\n            for (let pv of propValue) {\n                if (is.activity(pv)) {\n                    stuff.push(specStrings.hosting.createActivityInstancePart(pv.instanceId));\n                }\n                else {\n                    if (!serializer) {\n                        stuff.push(ser.toJSON(pv));\n                    }\n                    else {\n                        stuff.push(pv);\n                    }\n                }\n            }\n            result.name = propName;\n            result.value = stuff;\n            return true;\n        }\n        return false;\n    },\n    deserialize: function (serializer, activity, getActivityById, part, result) {\n        let ser = null;\n        if (!serializer) {\n            ser = new Serializer(); // It should get serialized internally.\n        }\n        if (_.isArray(part.value)) {\n            let scopePartValue = [];\n            for (let pv of part.value) {\n                let activityId = specStrings.hosting.getInstanceId(pv);\n                if (activityId) {\n                    scopePartValue.push(getActivityById(activityId));\n                }\n                else {\n                    if (!serializer) {\n                        scopePartValue.push(ser.fromJSON(pv));\n                    }\n                    else {\n                        scopePartValue.push(pv);\n                    }\n                }\n            }\n            result.value = scopePartValue;\n            return true;\n        }\n        return false;\n    }\n};\n\nlet activityHandler = {\n    serialize: function (serializer, activity, execContext, getActivityById, propName, propValue, result) {\n        if (is.activity(propValue)) {\n            result.name = propName;\n            result.value = specStrings.hosting.createActivityInstancePart(propValue.instanceId);\n            return true;\n        }\n        return false;\n    },\n    deserialize: function (serializer, activity, getActivityById, part, result) {\n        let activityId = specStrings.hosting.getInstanceId(part.value);\n        if (activityId) {\n            result.value = getActivityById(activityId);\n            return true;\n        }\n        return false;\n    }\n};\n\nlet parentHandler = {\n    serialize: function (serializer, activity, execContext, getActivityById, propName, propValue, result) {\n        if (propValue && propValue.__marker === constants.markers.$parent) {\n            result.name = propName;\n            result.value = {\n                $type: constants.markers.$parent,\n                id: propValue.$activity.instanceId\n            };\n            return true;\n        }\n        return false;\n    },\n    deserialize: function (serializer, activity, getActivityById, part, result) {\n        return false;\n    }\n};\n\nlet activityPropHandler = {\n    serialize: function (serializer, activity, execContext, getActivityById, propName, propValue, result) {\n        if (_.isFunction(propValue) && !activity.hasOwnProperty(propName) &&\n            _.isFunction(activity[propName])) {\n            result.value = specStrings.hosting.createActivityPropertyPart(propName);\n            return true;\n        }\n        else if (_.isObject(propValue) && propValue === activity[propName]) {\n            result.value = specStrings.hosting.createActivityPropertyPart(propName);\n            return true;\n        }\n        return false;\n    },\n    deserialize: function (serializer, activity, getActivityById, part, result) {\n        let activityProperty = specStrings.hosting.getActivityPropertyName(part);\n        if (activityProperty) {\n            if (_.isUndefined(activity[activityProperty])) {\n                throw new errors.ActivityRuntimeError(\"Activity has no property '\" + part + \"'.\");\n            }\n            result.name = activityProperty;\n            result.value = activity[activityProperty];\n            return true;\n        }\n        return false;\n    }\n};\n\nlet errorInstanceHandler = {\n    serialize: function (serializer, activity, execContext, getActivityById, propName, propValue, result) {\n        if (propValue instanceof Error) {\n            result.name = propName;\n            result.value = {\n                type: constants.types.error,\n                name: propValue.name,\n                stack: propValue.stack\n            };\n            return true;\n        }\n        return false;\n    },\n    deserialize: function (serializer, activity, getActivityById, part, result) {\n        if (part.value && part.value.type === constants.types.error) {\n            let errorName = part.value.name;\n            let ErrorConstructor = global[errorName];\n            if (_.isFunction(ErrorConstructor)) {\n                result.value = new ErrorConstructor(part.value.stack);\n            }\n            else {\n                result.value = new Error(`Error: ${errorName} Stack: ${part.value.stack}`);\n            }\n            return true;\n        }\n        return false;\n    }\n};\n\nlet objectHandler = {\n    serialize: function (serializer, activity, execContext, getActivityById, propName, propValue, result) {\n        if (serializer) {\n            return false; // it's handled externally.\n        }\n        if (propName === \"__schedulingState\") {\n            result.name = propName;\n            result.value = _.clone(propValue);\n            result.value.indices = converters.mapToArray(propValue.indices);\n            result.value.$type = constants.types.schedulingState;\n            return true;\n        }\n        if (_.isDate(propValue)) {\n            result.name = propName;\n            result.value = {\n                time: propValue.getTime(),\n                $type: constants.types.date\n            };\n            return true;\n        }\n        if (propValue instanceof Map) {\n            result.name = propName;\n            result.value = {\n                data: converters.mapToArray(propValue),\n                $type: constants.types.map\n            };\n            return true;\n        }\n        if (propValue instanceof Set) {\n            result.name = propName;\n            result.value = {\n                data: converters.setToArray(propValue),\n                $type: constants.types.set\n            };\n            return true;\n        }\n        if (propValue instanceof RegExp) {\n            result.name = propName;\n            result.value = {\n                pattern: propValue.pattern,\n                flags: propValue.flags,\n                $type: constants.types.rex\n            };\n            return true;\n        }\n        if (_.isPlainObject(propValue)) {\n            result.name = propName;\n            result.value = {\n                data: new Serializer().toJSON(propValue),\n                $type: constants.types.object\n            };\n            return true;\n        }\n        return false;\n    },\n    deserialize: function (serializer, activity, getActivityById, part, result) {\n        if (part.value) {\n            if (part.value.$type === constants.types.schedulingState) {\n                result.value = _.clone(part.value);\n                result.value.indices = converters.arrayToMap(part.value.indices);\n                delete result.value.$type;\n                return true;\n            }\n            if (part.value.$type === constants.types.date) {\n                result.value = new Date(part.value.time);\n                return true;\n            }\n            if (part.value.$type === constants.types.map) {\n                result.value = converters.arrayToMap(part.value.data);\n                return true;\n            }\n            if (part.value.$type === constants.types.set) {\n                result.value = converters.arrayToSet(part.value.data);\n                return true;\n            }\n            if (part.value.$type === constants.types.rex) {\n                result.value = new RegExp(part.value.pattern, part.value.flags);\n                return true;\n            }\n            if (part.value.$type === constants.types.object) {\n                result.value = new Serializer().fromJSON(part.value.data);\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nlet scopeSerializer = {\n    handlers: [],\n    installHandler: function (handler) {\n        this.handlers.push(handler);\n    },\n    serialize: function (execContext, getActivityById, enablePromotions, nodes, serializer) {\n        let state = [];\n        let promotedProperties = enablePromotions ? new Map() : null;\n\n        for (let node of nodes) {\n            if (node.instanceId === constants.ids.initialScope) {\n                continue;\n            }\n\n            let item = {\n                instanceId: node.instanceId,\n                userId: node.userId,\n                parentId: node.parent ? node.parent.instanceId : null,\n                parts: []\n            };\n\n            let activity = getActivityById(node.instanceId);\n\n            for (let prop of node.properties()) {\n                if (!activity.nonSerializedProperties.has(prop.name)) {\n                    let done = false;\n                    for (let handler of this.handlers) {\n                        let result = { name: null, value: null };\n                        if (handler.serialize(serializer, activity, execContext, getActivityById, prop.name, prop.value, result)) {\n                            if (result.name) {\n                                item.parts.push({\n                                    name: prop.name,\n                                    value: result.value\n                                });\n                            }\n                            else {\n                                item.parts.push(result.value);\n                            }\n                            done = true;\n                            break;\n                        }\n                    }\n                    if (!done) {\n                        item.parts.push({\n                            name: prop.name,\n                            value: prop.value\n                        });\n                    }\n                }\n            }\n\n            state.push(item);\n\n            // Promotions:\n            if (promotedProperties && activity.promotedProperties) {\n                for (let promotedPropName of activity.promotedProperties) {\n                    let pv = node.getPropertyValue(promotedPropName, true);\n                    if (!_.isUndefined(pv) && !(is.activity(pv))) {\n                        let promotedEntry = promotedProperties.get(promotedPropName);\n                        // If an Activity Id greater than other, then we can sure that other below or after in the tree.\n                        if (_.isUndefined(promotedEntry) || node.instanceId > promotedEntry.level) {\n                            promotedProperties.set(promotedPropName, { level: node.instanceId, value: pv });\n                        }\n                    }\n                }\n            }\n        }\n\n        let actualPromotions = null;\n        if (promotedProperties) {\n            actualPromotions = {};\n            for (let kvp of promotedProperties.entries()) {\n                actualPromotions[kvp[0]] = kvp[1].value;\n            }\n        }\n\n        return {\n            state: state,\n            promotedProperties: actualPromotions\n        };\n    },\n    deserializeNodes: function* (getActivityById, json, serializer) {\n        for (let item of json) {\n            let scopePart = {};\n            let activity = getActivityById(item.instanceId);\n            for (let part of item.parts) {\n                let done = false;\n                for (let handler of this.handlers) {\n                    let result = { name: null, value: null };\n                    if (handler.deserialize(serializer, activity, getActivityById, part, result)) {\n                        scopePart[result.name || part.name] = result.value;\n                        done = true;\n                        break;\n                    }\n                }\n                if (!done) {\n                    scopePart[part.name] = part.value;\n                }\n            }\n            yield new ScopeNode(item.instanceId, scopePart, item.userId, activity);\n        }\n    }\n};\n\nscopeSerializer.installHandler(arrayHandler);\nscopeSerializer.installHandler(activityHandler);\nscopeSerializer.installHandler(parentHandler);\nscopeSerializer.installHandler(objectHandler);\nscopeSerializer.installHandler(activityPropHandler);\nscopeSerializer.installHandler(errorInstanceHandler);\n\nmodule.exports = scopeSerializer;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/activityStateTracker.js":"\"use strict\";\n\nfunction ActivityStateTracker(impl) {\n    this._impl = impl;\n}\n\nActivityStateTracker.prototype.activityStateChanged = function (args) {\n    if (typeof this._impl.activityStateChanged === \"function\" && this.activityStateFilter(args)) {\n        this._impl.activityStateChanged.call(this._impl, args);\n    }\n};\n\nActivityStateTracker.prototype.activityStateFilter = function (args) {\n    if (typeof this._impl.activityStateFilter === \"function\") {\n        return this._impl.activityStateFilter(args);\n    }\n    else {\n        return true;\n    }\n};\n\nmodule.exports = ActivityStateTracker;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/activityMarkup.js":"\"use strict\";\n\n/* jshint -W061 */\n\nlet _ = require(\"lodash\");\nlet errors = require(\"../common/errors\");\nlet Activity = require(\"./activity\");\nlet is = require(\"../common/is\");\nlet path = require(\"path\");\nlet fs = require(\"fs\");\nlet Reflection = require(\"backpack-node\").system.Reflection;\nlet templateHelpers = require('./templateHelpers');\n\nconst activityTypeNameRex = /^\\@([a-zA-Z_]+[0-9a-zA-Z_]*)$/;\nfunction getActivityTypeName(str) {\n    if (_.isString(str)) {\n        let result = activityTypeNameRex.exec(str);\n        if (result && result.length === 2) {\n            return result[1];\n        }\n    }\n    return null;\n}\n\nfunction requireFromRoot(resource) {\n    try {\n        return require(resource);\n    }\n    catch (e) {\n        _.noop(e);\n    }\n    let pPos = resource.indexOf(\"/\");\n    if (pPos === -1) {\n        return require(resource);\n    }\n    let module = resource.substr(0, pPos);\n    if (!module) {\n        return require(resource);\n    }\n    try {\n        module = require(module);\n        let obj = module;\n        for (let key of resource.substr(pPos + 1).split(\"/\")) {\n            obj = obj[key];\n        }\n        return obj;\n    }\n    catch (e) {\n        return require(resource);\n    }\n}\n\nfunction ActivityMarkup() {\n    this._systemTypes = new Map();\n    this._registerSystemTypes();\n}\n\nActivityMarkup.prototype._registerSystemTypes = function () {\n    this._registerTypes(__dirname);\n};\n\nActivityMarkup.prototype._registerTypes = function (sourcePath) {\n    this._registerTypesTo(this._systemTypes, sourcePath);\n};\n\nActivityMarkup.prototype._registerTypesTo = function (types, sourcePath) {\n    let self = this;\n    let obj = requireFromRoot(sourcePath);\n    Reflection.visitObject(obj, function (inObj) {\n        let alias = self.getAlias(inObj);\n        if (alias && !types.has(alias)) {\n            // This is an activity type\n            types.set(alias, inObj);\n        }\n        return alias === null;\n    });\n};\n\nActivityMarkup.prototype.getAlias = function (type) {\n    if (_.isFunction(type) && !_.isUndefined(type.super_)) {\n        let alias = this._toCamelCase(type.name);\n        do\n        {\n            if (type.super_ === Activity) {\n                return alias;\n            }\n            type = type.super_;\n        }\n        while (type);\n    }\n    return null;\n};\n\nActivityMarkup.prototype._toCamelCase = function (id) {\n    return id[0].toLowerCase() + id.substr(1);\n};\n\nActivityMarkup.prototype.parse = function (markup) {\n    if (!markup) {\n        throw new TypeError(\"Parameter 'markup' expected.\");\n    }\n    if (_.isString(markup)) {\n        markup = JSON.parse(markup);\n    }\n    if (!_.isPlainObject(markup)) {\n        throw new TypeError(\"Parameter 'markup' is not a plain object.\");\n    }\n\n    let types = new Map();\n    for (let kvp of this._systemTypes.entries()) {\n        types.set(kvp[0], kvp[1]);\n    }\n    let req = markup[\"@require\"];\n    if (req) {\n        this._require(types, req);\n    }\n    let activity = this._createActivity(types, markup);\n    if (req) {\n        activity[\"@require\"] = req;\n    }\n    return activity;\n};\n\nActivityMarkup.prototype._createActivity = function (types, markup) {\n    let filedNames = _.filter(_.keys(markup), function (k) { return k !== \"@require\"; });\n    if (filedNames.length !== 1) {\n        throw new errors.ActivityMarkupError(\"There should be one field.\" + this._errorHint(markup));\n    }\n\n    let activityAlias = getActivityTypeName(filedNames[0]);\n    if (activityAlias) {\n        return this._createAndInitActivityInstance(types, activityAlias, markup);\n    }\n    else {\n        throw new errors.ActivityMarkupError(\"Root entry is not an activity type name '\" + filedNames[0] + \"'.\" + this._errorHint(markup));\n    }\n};\n\nActivityMarkup.prototype._createAndInitActivityInstance = function (types, typeName, markup) {\n    let activity = this._createActivityInstance(types, typeName);\n    if (!activity) {\n        throw new errors.ActivityMarkupError(\"Unknown activity type name '\" + typeName + \"'.\" + this._errorHint(markup));\n    }\n    let activityRef = {\n        name: typeName,\n        value: activity\n    };\n    let pars = markup[\"@\" + typeName];\n    if (pars) {\n        this._setupActivity(types, activityRef, pars);\n    }\n    return activityRef.value;\n};\n\nActivityMarkup.prototype._createActivityInstance = function (types, alias) {\n    let Constructor = types.get(alias);\n    if (_.isUndefined(Constructor)) {\n        return null;\n    }\n    return new Constructor();\n};\n\nActivityMarkup.prototype._setupActivity = function (types, activityRef, pars) {\n    let self = this;\n    let activity = activityRef.value;\n\n    function noFunction(fieldName) {\n        return activity.codeProperties.has(fieldName);\n    }\n\n    if (_.isArray(pars)) {\n        // args\n        activity.args = [];\n        for (let obj of pars) {\n            activity.args.push(self._createValue(types, obj, false, is.template(activity)));\n        }\n    }\n    else if (_.isObject(pars)) {\n        let to = null;\n        // values\n        for (let fieldName in pars) {\n            if (pars.hasOwnProperty(fieldName)) {\n                if (activity.isArrayProperty(fieldName)) {\n                    let v = self._createValue(types, pars[fieldName], true, is.template(activity));\n                    if (!_.isArray(v)) {\n                        v = [v];\n                    }\n                    activity[fieldName] = v;\n                }\n                else if (fieldName === \"@to\") {\n                    if (to) {\n                        throw new errors.ActivityMarkupError(\"Multiple to defined in activity '\" + activityRef.name + \".\" + this._errorHint(pars));\n                    }\n                    to = pars[fieldName];\n                }\n                else if (fieldName[0] === \"!\") {\n                    // Promoted:\n                    if (!activity.promotedProperties || !_.isFunction(activity.promoted)) {\n                        throw new errors.ActivityMarkupError(\"Activity '\" + activityRef.name + \" cannot have promoted properties.\" + this._errorHint(pars));\n                    }\n                    activity.promoted(fieldName.substr(1), self._createValue(types, pars[fieldName], true, is.template(activity)));\n                }\n                else if (fieldName[0] === \"`\") {\n                    // Reserved:\n                    if (!activity.reservedProperties || !_.isFunction(activity.reserved)) {\n                        throw new errors.ActivityMarkupError(\"Activity '\" + activityRef.name + \" cannot have reserved properties.\" + this._errorHint(pars));\n                    }\n                    activity.reserved(fieldName.substr(1), self._createValue(types, pars[fieldName], true, is.template(activity)));\n                }\n                else if (fieldName === \"@require\") {\n                    // Require:\n                    self._require(types, pars[fieldName]);\n                }\n                else {\n                    activity[fieldName] = self._createValue(types, pars[fieldName], false, is.template(activity), noFunction(fieldName));\n                }\n            }\n        }\n        if (to) {\n            let current = activity;\n            let assign = activityRef.value = this._createActivityInstance(types, \"assign\");\n            assign.value = current;\n            assign.to = to;\n        }\n    }\n    else {\n        // 1 arg\n        activity.args = [self._createValue(types, pars, false, is.template(activity))];\n    }\n};\n\nActivityMarkup.prototype._require = function (types, markup) {\n    let self = this;\n\n    if (_.isArray(markup)) {\n        for (let item of markup) {\n            self._require(types, item);\n        }\n    }\n    else if (_.isString(markup)) {\n        self._registerTypesTo(types, markup);\n    }\n    else {\n        throw new errors.ActivityMarkupError(\"Cannot register '\" + markup + \"'.\" + self._errorHint(markup));\n    }\n};\n\nActivityMarkup.prototype._createValue = function (types, markup, canBeArray, noTemplate, noFunction) {\n    let self = this;\n\n    // Helpers\n    function toTemplate(_markup) {\n        let template = self._createActivityInstance(types, \"template\");\n        template.declare = _markup;\n        return template;\n    }\n\n    function toFunc(f) {\n        let func = self._createActivityInstance(types, \"func\");\n        func.code = f;\n        return func;\n    }\n\n    function toExpression(str) {\n        let expr = self._createActivityInstance(types, \"expression\");\n        expr.expr = str;\n        return expr;\n    }\n\n    if (_.isArray(markup)) {\n        if (canBeArray) {\n            let result = [];\n            for (let v of markup) {\n                result.push(self._createValue(types, v));\n            }\n            return result;\n        }\n        else if (!noTemplate && templateHelpers.isTemplate(markup)) {\n            return toTemplate(markup);\n        }\n    }\n    else if (_.isPlainObject(markup)) {\n        let filedNames = _.keys(markup);\n        if (filedNames.length === 1) {\n            let fieldName = filedNames[0];\n            let fieldValue = markup[fieldName];\n\n            if (fieldName === \"_\") {\n                // Escape:\n                return fieldValue;\n            }\n\n            let activityTypeName = getActivityTypeName(fieldName);\n            if (activityTypeName) {\n                // Activity:\n                return self._createAndInitActivityInstance(types, activityTypeName, markup);\n            }\n        }\n\n        // Plain object:\n        if (!noTemplate && templateHelpers.isTemplate(markup)) {\n            return toTemplate(markup);\n        }\n    }\n    else if (_.isString(markup)) {\n        let str = markup.trim();\n        if (templateHelpers.isFunctionString(str)) {\n            let f;\n            eval(\"f = function(_){return (\" + str + \");}\");\n            f = f(_);\n            if (!noFunction) {\n                return toFunc(f);\n            }\n            else {\n                return f; // aka when func.code\n            }\n        }\n        else if (str.length > 1) {\n            if (str[0] === \"=\") {\n                // Expression\n                return toExpression(str.substr(1));\n            }\n        }\n    }\n    else if (_.isFunction(markup)) {\n        if (!noFunction) {\n            return toFunc(markup);\n        }\n    }\n\n    return this._clone(markup);\n};\n\nActivityMarkup.prototype._clone = function(obj) {\n    return templateHelpers.cloneDeep(obj);\n};\n\nActivityMarkup.prototype._errorHint = function (markup) {\n    let len = 20;\n    let json = JSON.stringify(markup);\n    if (json.length > len) {\n        json = json.substr(0, len) + \" ...\";\n    }\n    return \"\\nSee error near:\\n\" + json;\n};\n\nActivityMarkup.prototype.stringify = function (obj) {\n    if (_.isString(obj)) {\n        return obj;\n    }\n    if (is.activity(obj)) {\n        obj = this.toMarkup(obj);\n    }\n    if (!_.isPlainObject(obj)) {\n        throw new TypeError(\"Parameter 'obj' is not a plain object.\");\n    }\n    let cloned = _.cloneDeep(obj);\n    this._functionsToString(cloned);\n    return JSON.stringify(cloned);\n};\n\nActivityMarkup.prototype._functionsToString = function (obj) {\n    let self = this;\n    for (let fieldName in obj) {\n        let fieldValue = obj[fieldName];\n        if (_.isFunction(fieldValue)) {\n            obj[fieldName] = fieldValue.toString();\n        }\n        else if (_.isObject(fieldValue)) {\n            self._functionsToString(fieldValue);\n        }\n        else if (_.isArray(fieldValue)) {\n            for (let v of fieldValue) {\n                self._functionsToString(v);\n            }\n        }\n    }\n};\n\n// To Markup:\n\nActivityMarkup.prototype.toMarkup = function (activity) {\n    /*if (!is.activity(activity)) {\n        throw new TypeError(\"Argument is not an activity instance.\");\n    }\n    let markup = {};\n    let alias = this.getAlias(activity.constructor);\n    let activityMarkup = this._createMarkupOfActivity(activity);*/\n    throw new Error(\"Not supported yet!\");\n};\n\n// Exports:\n\nlet activityMarkup = null;\n\nmodule.exports = {\n    parse: function (markup) {\n        return (activityMarkup = (activityMarkup || new ActivityMarkup())).parse(markup);\n    },\n\n    toMarkup: function (activity) {\n        return (activityMarkup = (activityMarkup || new ActivityMarkup())).toMarkup(activity);\n    },\n\n    stringify: function (obj) {\n        return (activityMarkup = (activityMarkup || new ActivityMarkup())).stringify(obj);\n    },\n\n    getAlias: function (activity) {\n        return (activityMarkup = (activityMarkup || new ActivityMarkup())).getAlias(activity.constructor);\n    }\n};","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/templateHelpers.js":"\"use strict\";\n\nlet _ = require(\"lodash\");\nlet Reflection = require(\"backpack-node\").system.Reflection;\n\nlet maxDepth = 10;\n\nlet templateHelpers = {\n\n    isFunctionString: function (str) {\n        return _.isString(str) && str.match(/^\\s*function\\s*\\w*\\s*\\((?:\\w+,)*(?:\\w+)?\\)\\s*\\{/);\n    },\n    isTemplate: function (obj) {\n        let activityCount = 0;\n        templateHelpers.visitActivities(obj, function () {\n            activityCount++;\n        });\n        return activityCount > 0;\n    },\n    visitActivities: function (obj, f) {\n        if (!_.isPlainObject(obj) && !_.isArray(obj)) {\n            return;\n        }\n        Reflection.visitObject(obj,\n            function (subObj, parent, pkey) {\n                if (_.isString(subObj)) {\n                    let str = subObj.trim();\n                    if (str.length > 1) {\n                        if (str[0] === \"=\") {\n                            let markup = {\n                                \"@expression\": {\n                                    expr: str.substr(1)\n                                }\n                            };\n                            f(markup, parent, pkey);\n                            return false;\n                        }\n                        if (templateHelpers.isFunctionString(str)) {\n                            let markup = {\n                                \"@func\": {\n                                    code: str\n                                }\n                            };\n                            f(markup, parent, pkey);\n                            return false;\n                        }\n                    }\n                }\n                else if (_.isPlainObject(subObj)) {\n                    let keys = _.keys(subObj);\n\n                    if (keys.length === 1) {\n                        let key = keys[0];\n                        if (key[0] === \"@\" && key.length > 1) {\n                            let markup = {};\n                            markup[key] = subObj[key];\n                            f(markup, parent, pkey);\n                            return false;\n                        }\n                    }\n                    else if (keys.length === 2) {\n                        let key1 = keys[0];\n                        let key2 = keys[1];\n                        if (key1 === \"@require\" && key2[0] === \"@\" && key2.length > 1) {\n                            let markup = {};\n                            markup[key1] = subObj[key1];\n                            markup[key2] = subObj[key2];\n                            f(markup, parent, pkey);\n                            return false;\n                        }\n                        else if (key2 === \"@require\" && key1[0] === \"@\" && key1.length > 1) {\n                            let markup = {};\n                            markup[key2] = subObj[key2];\n                            markup[key1] = subObj[key1];\n                            f(markup, parent, pkey);\n                            return false;\n                        }\n                    }\n                }\n                else if (_.isFunction(subObj)) {\n                    let markup = {\n                        \"@func\": {\n                            code: subObj\n                        }\n                    };\n                    f(markup, parent, pkey);\n                    return false;\n                }\n                return true;\n            },\n            maxDepth);\n    },\n    cloneDeep: function(obj) {\n        if (_.isPlainObject(obj)) {\n            let other = {};\n            for (let key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    other[key] = this.cloneDeep(obj[key]);\n                }\n            }\n            return other;\n        }\n        else if (_.isArray(obj)) {\n            let other = [];\n            for (let item of obj) {\n                other.push(this.cloneDeep(item));\n            }\n            return other;\n        }\n        else if (_.isObject(obj) && _.isFunction(obj.clone)) {\n            return obj.clone();\n        }\n        return obj;\n    }\n};\n\nmodule.exports = templateHelpers;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/assign.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction Assign() {\n    Activity.call(this);\n    this.value = null;\n    this.to = \"\";\n}\n\nutil.inherits(Assign, Activity);\n\nAssign.prototype.run = function (callContext, args) {\n    if (this.to) {\n        callContext.schedule(this.value, \"_valueGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nAssign.prototype._valueGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        this[this.to] = result;\n    }\n    callContext.end(reason, result);\n};\n\nmodule.exports = Assign;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/beginMethod.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet specStrings = require(\"../common/specStrings\");\nlet errors = require(\"../common/errors\");\n\nfunction BeginMethod() {\n    Activity.call(this);\n    this.canCreateInstance = false;\n    this.methodName = null;\n    this.instanceIdPath = null;\n}\n\nutil.inherits(BeginMethod, Activity);\n\nBeginMethod.prototype.run = function (callContext, args) {\n    let methodName = this.methodName;\n    if (_.isString(methodName)) {\n        let mn = methodName.trim();\n        if (mn) {\n            callContext.createBookmark(specStrings.hosting.createBeginMethodBMName(mn), \"_methodInvoked\");\n            callContext.idle();\n            return;\n        }\n    }\n    callContext.fail(new errors.ValidationError(\"BeginMethod activity methodName property's value '\" + methodName + \"' must be a valid identifier.\"));\n};\n\nBeginMethod.prototype._methodInvoked = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = BeginMethod;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/block.js":"var Activity = require(\"./activity\");\nvar util = require(\"util\");\nvar Declarator = require(\"./declarator\");\n\nfunction Block() {\n    Declarator.call(this);\n}\n\nutil.inherits(Block, Declarator);\n\nBlock.prototype.varsDeclared = function (callContext, args) {\n    var todo = [];\n    this._todo = todo;\n    if (args.length) {\n        for (var i = args.length - 1; i >= 1; i--) {\n            todo.push(args[i]);\n        }\n        callContext.schedule(args[0], \"_argGot\");\n    }\n    else {\n        callContext.end(Activity.states.complete, null);\n    }\n}\n\nBlock.prototype._argGot = function (callContext, reason, result) {\n    var todo = this._todo;\n    if (reason === Activity.states.complete) {\n        if (todo.length === 0) {\n            callContext.complete(result);\n        }\n        else {\n            callContext.schedule(todo.pop(), \"_argGot\");\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n}\n\nmodule.exports = Block;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/declarator.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet is = require(\"../common/is\");\nlet _ = require(\"lodash\");\n\nfunction Declarator() {\n    Activity.call(this);\n    this.nonScopedProperties.add(\"reservedProperties\");\n    this.nonScopedProperties.add(\"reserved\");\n    this.nonScopedProperties.add(\"promotedProperties\");\n    this.nonScopedProperties.add(\"promoted\");\n    this.nonScopedProperties.add(\"varsDeclared\");\n\n    // Properties those cannot be declared freely\n    this.reservedProperties = new Set();\n\n    // Properties those will be promoted during serialization\n    this.promotedProperties = new Set();\n}\n\nutil.inherits(Declarator, Activity);\n\nDeclarator.prototype.reserved = function (name, value) {\n    if (this.promotedProperties.has(name)) {\n        throw new Error(\"Property '\" + name + \"' cannot be reserved because it's promoted.\");\n    }\n    if (!_.isUndefined(value)) {\n        this[name] = value;\n    }\n    this.reservedProperties.add(name);\n};\n\nDeclarator.prototype.promoted = function (name, value) {\n    if (this.reservedProperties.has(name)) {\n        throw new Error(\"Property '\" + name + \"' cannot be promoted because it's reserved.\");\n    }\n    if (!_.isUndefined(value)) {\n        this[name] = value;\n    }\n    this.promotedProperties.add(name);\n};\n\nDeclarator.prototype.run = function (callContext, args) {\n    let activityVariables = [];\n    let _activityVariableFieldNames = [];\n    this._activityVariableFieldNames = _activityVariableFieldNames;\n    let resProps = callContext.activity.reservedProperties;\n    for (let fieldName of callContext.activity._getScopeKeys()) {\n        if (!resProps.has(fieldName)) {\n            let fieldValue = this[fieldName];\n            if (fieldValue instanceof Activity) {\n                activityVariables.push(fieldValue);\n                _activityVariableFieldNames.push(fieldName);\n            }\n        }\n    }\n\n    if (activityVariables.length) {\n        this._savedArgs = args;\n        callContext.schedule(activityVariables, \"_varsGot\");\n    }\n    else {\n        this.delete(\"_activityVariableFieldNames\");\n        callContext.activity.varsDeclared.call(this, callContext, args);\n    }\n};\n\nDeclarator.prototype._varsGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        let idx = 0;\n        for (let fieldName of this._activityVariableFieldNames) {\n            this[fieldName] = result[idx++];\n        }\n        let args = this._savedArgs;\n        this.delete(\"_savedArgs\");\n        this.delete(\"_activityVariableFieldNames\");\n        callContext.activity.varsDeclared.call(this, callContext, args);\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = Declarator;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/consoleTracker.js":"\"use strict\";\n\nlet _ = require(\"lodash\");\nlet util = require(\"util\");\nlet Activity = require(\"./activity\");\n\nfunction ConsoleTracker() {\n}\n\nConsoleTracker.prototype.activityStateChanged = function (args) {\n    let activity = args.scope.$activity;\n    let reason = args.reason;\n    let result = args.result;\n    let name = activity.toString();\n    if (result instanceof Error) {\n        result = result.message;\n    }\n    else {\n        if (_.isObject(result)) result = util.inspect(result);\n        if (_.isString(result) && result.length > 100) result = result.substr(0, 100);\n    }\n    if (result) result = \", result: \" + result; else result = \"\";\n    let method = reason === Activity.states.fail? \"error\" : \"log\";\n    console[method](\"Activity '\" + name + \"' state changed - reason: \" + reason + result);\n};\n\nmodule.exports = ConsoleTracker;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/endMethod.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\nlet _ = require(\"lodash\");\n\nfunction EndMethod() {\n    Activity.call(this);\n    this.methodName = null;\n    this.instanceIdPath = null;\n    this.result = null;\n}\n\nutil.inherits(EndMethod, Activity);\n\nEndMethod.prototype.run = function (callContext, args) {\n    let methodName = this.methodName;\n    if (_.isString(methodName)) {\n        let mn = methodName.trim();\n        if (mn) {\n            callContext.schedule(this.result, \"_resultGot\");\n            return;\n        }\n    }\n    callContext.fail(new errors.ValidationError(\"EndMethod activity methodName property's value must be a valid identifier.\"));\n};\n\nEndMethod.prototype._resultGot = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = EndMethod;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/func.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet common = require(\"../common\");\nlet errors = common.errors;\nlet constants = common.constants;\nlet async = common.asyncHelpers.async;\n\nfunction Func(code) {\n    Activity.call(this);\n    this.code = code || null;\n    this.codeProperties.add(\"code\");\n}\n\nFunc.async = function(code) {\n    return new Func(async(code));\n};\n\nutil.inherits(Func, Activity);\n\nFunc.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nFunc.prototype._argsGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        this._args = result;\n        callContext.schedule(this.code, \"_codeGot\");\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nFunc.prototype._codeGot = function (callContext, reason, result) {\n    let code = result;\n    if (reason === Activity.states.complete) {\n        if (!_.isFunction(code)) {\n            callContext.fail(new errors.ValidationError(\"Func activity's property 'code' is not a function.\"));\n            return;\n        }\n\n        try {\n            let fResult = code.apply(this, (this._args || []).concat(_, this));\n            if (_.isObject(fResult) && _.isFunction(fResult.then)) {\n                fResult.then(\n                    function (v) {\n                        callContext.complete(v);\n                    },\n                    function (err) {\n                        callContext.fail(err);\n                    });\n            }\n            else {\n                callContext.complete(fResult);\n            }\n        }\n        catch(e) {\n            callContext.fail(e);\n        }\n    }\n    else {\n        callContext.end(reason, this._args);\n    }\n};\n\nmodule.exports = Func;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/parallel.js":"var Activity = require(\"./activity\");\nvar util = require(\"util\");\nvar Declarator = require(\"./declarator\");\nvar errors = require(\"../common/errors\");\n\nfunction Parallel() {\n    Declarator.call(this);\n}\n\nutil.inherits(Parallel, Declarator);\n\nParallel.prototype.varsDeclared = function (callContext, args) {\n    if (args && args.length) {\n        callContext.schedule(args, \"_argsGot\");\n    }\n    else {\n        callContext.complete([]);\n    }\n}\n\nParallel.prototype._argsGot = function (callContext, reason, result) {\n    callContext.end(reason, result);\n}\n\nmodule.exports = Parallel;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/pick.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet Declarator = require(\"./declarator\");\nlet errors = require(\"../common/errors\");\n\nfunction Pick() {\n    Declarator.call(this);\n}\n\nutil.inherits(Pick, Declarator);\n\nObject.defineProperties(Pick.prototype, {\n    collectAll: {\n        value: false,\n        writable: false,\n        enumerable: false\n    }\n});\n\nPick.prototype.varsDeclared = function (callContext, args) {\n    if (args && args.length) {\n        callContext.schedule(args, \"_argsGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nPick.prototype._argsGot = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Pick;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/resumeBookmark.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\n\nfunction ResumeBookmark() {\n    Activity.call(this);\n    this.bookmarkName = \"\";\n    this.reason = Activity.states.complete;\n    this.mustExists = true;\n}\n\nResumeBookmark.validReasons = [Activity.states.complete, Activity.states.fail, Activity.states.cancel];\n\nutil.inherits(ResumeBookmark, Activity);\n\nResumeBookmark.prototype.run = function (callContext, args) {\n    let bookmarkName = this.bookmarkName;\n    let reason = this.reason;\n\n    if (!bookmarkName) {\n        callContext.fail(new errors.ValidationError(\"Bookmark name expected.\"));\n    }\n    if (ResumeBookmark.validReasons.indexOf(reason) === -1) {\n        callContext.fail(new errors.ValidationError(\"Reason value '\" + reason + \"' is not valid.\"));\n    }\n\n    let result = false;\n    if (this.mustExists) {\n        callContext.resumeBookmark(bookmarkName, reason, args);\n        result = true;\n    }\n    else {\n        if (callContext.executionContext.isBookmarkExists(bookmarkName)) {\n            callContext.resumeBookmark(bookmarkName, reason, args);\n            result = true;\n        }\n    }\n\n    callContext.complete(result);\n};\n\nmodule.exports = ResumeBookmark;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/waitForBookmark.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction WaitForBookmark() {\n    Activity.call(this);\n    this.bookmarkName = \"\";\n}\n\nutil.inherits(WaitForBookmark, Activity);\n\nWaitForBookmark.prototype.run = function (callContext, args) {\n    let bookmarkName = this.bookmarkName;\n\n    if (!bookmarkName) {\n        callContext.fail(new Error(\"WaitForBookmark activity's property 'bookmarkName' is not a non-empty string.\"));\n        return;\n    }\n\n    callContext.createBookmark(bookmarkName, \"_bmReached\");\n    callContext.idle();\n};\n\nWaitForBookmark.prototype._bmReached = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = WaitForBookmark;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/workflow.js":"var Block = require(\"./block\");\nvar util = require(\"util\");\n\nfunction Workflow(name) {\n    Block.call(this);\n\n    this.reserved(\"version\", 0);\n    this.reserved(\"name\", name ? name.toString() : \"\");\n}\n\nutil.inherits(Workflow, Block);\n\nmodule.exports = Workflow;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/if.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet Block = require(\"./block\");\nlet _ = require(\"lodash\");\n\nfunction If() {\n    Activity.call(this);\n\n    this.arrayProperties.add(\"then\");\n    this.arrayProperties.add(\"else\");\n\n    this.condition = null;\n    this.then = null;\n    this.else = null;\n}\n\nutil.inherits(If, Activity);\n\nIf.prototype.initializeStructure = function() {\n    if (this.then) {\n        let prev = this.then;\n        this.then = new Block();\n        this.then.args = prev;\n    }\n    if (this.else) {\n        let prev = this.else;\n        this.else = new Block();\n        this.else.args = prev;\n    }\n};\n\nIf.prototype.run = function (callContext, args) {\n    let condition = this.condition;\n    if (condition) {\n        callContext.schedule(condition, \"_conditionGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nIf.prototype._conditionGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        if (result) {\n            let then = this.then;\n            if (then) {\n                callContext.schedule(then, \"_bodyFinished\");\n                return;\n            }\n        }\n        else {\n            let _else = this.else;\n            if (_else) {\n                callContext.schedule(_else, \"_bodyFinished\");\n                return;\n            }\n        }\n        callContext.complete();\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nIf.prototype._bodyFinished = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = If;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/while.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet WithBody = require(\"./withBody\");\n\nfunction While() {\n    WithBody.call(this);\n\n    this.condition = null;\n}\n\nutil.inherits(While, WithBody);\n\nWhile.prototype.run = function (callContext, args) {\n    let condition = this.condition;\n    if (condition) {\n        callContext.schedule(condition, \"_conditionGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nWhile.prototype._conditionGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        if (!result) {\n            callContext.complete(this._lastBodyResult);\n        }\n        else {\n            WithBody.prototype.run.call(this, callContext);\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nWhile.prototype.bodyCompleted = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        this._lastBodyResult = result;\n        callContext.schedule(this.condition, \"_conditionGot\");\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = While;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/withBody.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet Block = require(\"./block\");\n\nfunction WithBody() {\n    Activity.call(this);\n\n    this._body = null;\n}\n\nutil.inherits(WithBody, Activity);\n\nWithBody.prototype.initializeStructure = function() {\n    this._body = new Block();\n    this._body.args = this.args;\n    this.args = null;\n};\n\nWithBody.prototype.run = function (callContext, args) {\n    let _body = args && args.length ? args : this._body;\n    if (_body.args && _body.args.length) {\n        callContext.schedule(_body, \"bodyCompleted\");\n    }\n    else {\n        this.bodyCompleted(callContext, Activity.states.complete);\n    }\n};\n\nWithBody.prototype.bodyCompleted = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = WithBody;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/method.js":"\"use strict\";\n\nlet Composite = require(\"./composite\");\nlet util = require(\"util\");\n\nfunction Method() {\n    Composite.call(this);\n\n    this.reserved(\"canCreateInstance\", false);\n    this.reserved(\"methodName\", null);\n    this.reserved(\"instanceIdPath\", \"\");\n    this.result = null;\n}\n\nutil.inherits(Method, Composite);\n\nMethod.prototype.createImplementation = function () {\n    return {\n        \"@block\": {\n            id: \"_methodBlock\",\n            a: null,\n            args: [\n                {\n                    \"@beginMethod\": {\n                        canCreateInstance: this.canCreateInstance,\n                        methodName: this.methodName,\n                        instanceIdPath: this.instanceIdPath,\n                        \"@to\": \"a\"\n                    }\n                },\n                {\n                    \"@endMethod\": {\n                        methodName: this.methodName,\n                        result: \"= this._methodBlock.$parent.result\"\n                    }\n                },\n                \"= this.a\"\n            ]\n        }\n    };\n};\n\nmodule.exports = Method;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/composite.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet constants = require(\"../common/constants\");\nlet Declarator = require(\"./declarator\");\nlet is = require(\"../common/is\");\nlet _ = require(\"lodash\");\nlet activityMarkup = require(\"./activityMarkup\");\nlet assert = require(\"assert\");\n\nfunction Composite() {\n    Declarator.call(this);\n\n    this.reservedProperties.add(\"_implementation\");\n    this.nonSerializedProperties.add(\"_implementation\");\n    this.nonScopedProperties.add(\"createImplementation\");\n    this.nonScopedProperties.add(\"ensureImplementationCreated\");\n    this.nonScopedProperties.add(\"implementationCompleted\");\n}\n\nutil.inherits(Composite, Declarator);\n\nComposite.prototype.createImplementation = function (execContext) {\n    throw new Error(\"Method 'createImplementation' not implemented.\");\n};\n\nComposite.prototype.ensureImplementationCreated = function (execContext) {\n    assert(!!execContext);\n    if (_.isUndefined(this._implementation)) {\n        this._implementation = this.createImplementation(execContext);\n        if (_.isPlainObject(this._implementation)) {\n            this._implementation = activityMarkup.parse(this._implementation);\n        }\n        if (!(this._implementation instanceof Activity)) {\n            throw new Error(\"Method 'createImplementation' must return an activity.\");\n        }\n    }\n};\n\nComposite.prototype.initializeStructure = function (execContext) {\n    assert(!!execContext);\n    this.ensureImplementationCreated(execContext);\n};\n\nComposite.prototype.run = function (callContext, args) {\n    if (!(this._implementation instanceof Activity)) {\n        throw new Error(\"Composite activity's implementation is not available.\");\n    }\n    Declarator.prototype.run.call(this, callContext, args);\n};\n\nComposite.prototype.varsDeclared = function (callContext, args) {\n    callContext.schedule(this._implementation, \"_implInvoked\");\n};\n\nComposite.prototype._implInvoked = function (callContext, reason, result) {\n    callContext.activity.implementationCompleted.call(this, callContext, reason, result);\n};\n\nComposite.prototype.implementationCompleted = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Composite;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/template.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet activityMarkup = require(\"./activityMarkup\");\nlet is = require(\"../common/is\");\nlet templateHelpers = require(\"./templateHelpers\");\nlet constants = require(\"../common/constants\");\n\nfunction Template() {\n    Activity.call(this);\n\n    this.declare = null;\n\n    this.nonScopedProperties.add(\"_visitActivities\");\n    this.nonScopedProperties.add(\"_getInternalActivities\");\n}\n\nutil.inherits(Template, Activity);\n\nTemplate.prototype.initializeStructure = function(execContext) {\n    let self = this;\n    let require = execContext.rootActivity[\"@require\"];\n    self.args = [];\n    templateHelpers.visitActivities(self.declare,\n        function(markup, parent, key) {\n            if (require) {\n                markup = templateHelpers.cloneDeep(markup);\n                markup[\"@require\"] = require;\n            }\n            self.args.push(activityMarkup.parse(markup));\n        });\n};\n\nTemplate.prototype.run = function(callContext, args) {\n    if (_.isArray(args)) {\n        callContext.schedule(args, \"_activitiesGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nTemplate.prototype._activitiesGot = function(callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        if (_.isArray(result) && result.length) {\n            let idx = 0;\n            let declare = _.cloneDeep(this.declare);\n            let setupTasks = [];\n            templateHelpers.visitActivities(declare, function(markup, parent, key) {\n                setupTasks.push(function() {\n                    parent[key] = result[idx++];\n                });\n            });\n            for (let t of setupTasks) {\n                t();\n            }\n            callContext.complete(declare);\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = Template;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/truthy.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction Truthy() {\n    Activity.call(this);\n\n    this.value = false;\n    this.is = true;\n    this.isNot = false;\n}\n\nutil.inherits(Truthy, Activity);\n\nTruthy.prototype.run = function(callContext, args) {\n    callContext.schedule(this.value, \"_valueGot\");\n};\n\nTruthy.prototype._valueGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    if (result) {\n        callContext.schedule(this.is, \"_done\");\n    }\n    else {\n        callContext.schedule(this.isNot, \"_done\");\n    }\n};\n\nTruthy.prototype._done = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Truthy;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/falsy.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction Falsy() {\n    Activity.call(this);\n\n    this.value = false;\n    this.is = true;\n    this.isNot = false;\n}\n\nutil.inherits(Falsy, Activity);\n\nFalsy.prototype.run = function(callContext, args) {\n    callContext.schedule(this.value, \"_valueGot\");\n};\n\nFalsy.prototype._valueGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    if (result) {\n        callContext.schedule(this.isNot, \"_done\");\n    }\n    else {\n        callContext.schedule(this.is, \"_done\");\n    }\n};\n\nFalsy.prototype._done = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Falsy;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/equals.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction Equals() {\n    Activity.call(this);\n\n    this.value = null;\n    this.to = null;\n    this.is = true;\n    this.isNot = false;\n    this.strict = false;\n}\n\nutil.inherits(Equals, Activity);\n\nEquals.prototype.run = function(callContext, args) {\n    callContext.schedule([this.value, this.to], \"_valueAndToGot\");\n};\n\nEquals.prototype._valueAndToGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    if (this.strict ? result[0] === result[1] : result[0] === result[1]) {\n        callContext.schedule(this.is, \"_done\");\n    }\n    else {\n        callContext.schedule(this.isNot, \"_done\");\n    }\n};\n\nEquals.prototype._done = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Equals;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/notEquals.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction NotEquals() {\n    Activity.call(this);\n\n    this.value = null;\n    this.to = null;\n    this.is = true;\n    this.isNot = false;\n    this.strict = false;\n}\n\nutil.inherits(NotEquals, Activity);\n\nNotEquals.prototype.run = function(callContext, args) {\n    callContext.schedule([this.value, this.to], \"_valueAndToGot\");\n};\n\nNotEquals.prototype._valueAndToGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    if (this.strict ? result[0] === result[1] : result[0] === result[1]) {\n        callContext.schedule(this.isNot, \"_done\");\n    }\n    else {\n        callContext.schedule(this.is, \"_done\");\n    }\n};\n\nNotEquals.prototype._done = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = NotEquals;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/not.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction Not() {\n    Activity.call(this);\n\n    this.isTrue = true;\n    this.isFalse = false;\n}\n\nutil.inherits(Not, Activity);\n\nNot.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nNot.prototype._argsGot = function (callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    let isTrue = false;\n    if (_.isArray(result) && result.length > 0) {\n        isTrue = result[0] ? true : false;\n    }\n\n    if (isTrue) {\n        callContext.schedule(this.isFalse, \"_done\");\n    }\n    else {\n        callContext.schedule(this.isTrue, \"_done\");\n    }\n};\n\nNot.prototype._done = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Not;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/and.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction And() {\n    Activity.call(this);\n\n    this.isTrue = true;\n    this.isFalse = false;\n}\n\nutil.inherits(And, Activity);\n\nAnd.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nAnd.prototype._argsGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    let isTrue = false;\n    if (result.length) {\n        isTrue = true;\n        for (let v of result) {\n            isTrue = (v ? true : false) && isTrue;\n        }\n    }\n\n    if (isTrue) {\n        callContext.schedule(this.isTrue, \"_done\");\n    }\n    else {\n        callContext.schedule(this.isFalse, \"_done\");\n    }\n};\n\nAnd.prototype._done = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = And;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/or.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction Or() {\n    Activity.call(this);\n\n    this.isTrue = true;\n    this.isFalse = false;\n}\n\nutil.inherits(Or, Activity);\n\nOr.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nOr.prototype._argsGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    let isTrue = false;\n    for (let v of result) {\n        isTrue = (v ? true : false) || isTrue;\n    }\n\n    if (isTrue) {\n        callContext.schedule(this.isTrue, \"_done\");\n    }\n    else {\n        callContext.schedule(this.isFalse, \"_done\");\n    }\n};\n\nOr.prototype._done = function(callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nmodule.exports = Or;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/for.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet WithBody = require(\"./withBody\");\n\nfunction For() {\n    WithBody.call(this);\n\n    this.from = null;\n    this.to = null;\n    this.step = 1;\n    this.varName = \"i\";\n\n    this.nonScopedProperties.add(\"_doStep\");\n}\n\nutil.inherits(For, WithBody);\n\nFor.prototype.run = function (callContext, args) {\n    const varName = this.varName;\n    let from = this.from;\n    let to = this.to;\n    let step = this.step;\n    if (!_.isNull(from) && !_.isNull(to) && !_.isNull(step)) {\n        this[varName] = null;\n        callContext.schedule([from, to, step], \"_valuesGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nFor.prototype._valuesGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        this._from = result[0];\n        this._to = result[1];\n        this._step = result[2];\n        callContext.activity._doStep.call(this, callContext);\n    }\n    else {\n        callContext.to(reason, result);\n    }\n};\n\nFor.prototype._doStep = function (callContext, lastResult) {\n    const varName = this.varName;\n    let from = this._from;\n    let to = this._to;\n    let step = this._step;\n    if (!_.isNumber(from)) {\n        callContext.fail(new TypeError(`\"For activity's from value '${from}' is not a number.`));\n        return;\n    }\n    if (!_.isNumber(to)) {\n        callContext.fail(new TypeError(`\"For activity's to value '${to}' is not a number.`));\n        return;\n    }\n    if (!_.isNumber(step)) {\n        callContext.fail(new TypeError(`\"For activity's from value '${step}' is not a number.`));\n        return;\n    }\n    let current;\n    if (_.isNull(this[varName])) {\n        current = this[varName] = from;\n    }\n    else {\n        current = this[varName] = (this[varName] + step);\n    }\n    if (step >= 0 && current >= to) {\n        callContext.complete(lastResult);\n    }\n    else if (step < 0 && current <= to) {\n        callContext.complete(lastResult);\n    }\n    else {\n        WithBody.prototype.run.call(this, callContext);\n    }\n};\n\nFor.prototype.bodyCompleted = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        callContext.activity._doStep.call(this, callContext, result);\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = For;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/forEach.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet is = require(\"../common/is\");\nlet Block = require(\"./block\");\nlet WithBody = require(\"./withBody\");\nlet errors = require(\"../common/errors\");\n\nfunction ForEach() {\n    WithBody.call(this);\n\n    this.items = null;\n    this.varName = \"item\";\n    this.parallel = false;\n    this._bodies = null;\n}\n\nutil.inherits(ForEach, WithBody);\n\nForEach.prototype.initializeStructure = function() {\n    if (this.parallel) {\n        let numCPUs = require(\"os\").cpus().length;\n        this._bodies = [];\n        if (this.args && this.args.length) {\n            for (let i = 0; i < Math.min(process.env.UV_THREADPOOL_SIZE || 100000, numCPUs); i++) {\n                let newArgs = [];\n                for (let arg of this.args) {\n                    if (arg instanceof Activity) {\n                        newArgs.push(arg.clone());\n                    }\n                    else {\n                        newArgs.push(arg);\n                    }\n                }\n                let newBody = new Block();\n                newBody.args = newArgs;\n                this._bodies.push(newBody);\n            }\n        }\n        this.args = null;\n    }\n    else {\n        WithBody.prototype.initializeStructure.call(this);\n    }\n};\n\nForEach.prototype.run = function (callContext, args) {\n    const varName = this.varName;\n    let items = this.items;\n    if (!_.isNull(items)) {\n        this[varName] = null;\n        callContext.schedule(items, \"_itemsGot\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nForEach.prototype._itemsGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete && !_.isUndefined(result)) {\n        if (result && _.isFunction(result.next)) {\n            this._iterator = result;\n        }\n        else {\n            this._remainingItems = _.isArray(result) ? result : [result];\n        }\n        callContext.activity._doStep.call(this, callContext);\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nForEach.prototype._doStep = function (callContext, lastResult) {\n    const varName = this.varName;\n    let remainingItems = this._remainingItems;\n    let iterator = this._iterator;\n    if (remainingItems && remainingItems.length) {\n        if (this.parallel) {\n            let bodies = this._bodies;\n            let pack = [];\n            let idx = 0;\n            while (remainingItems.length && idx < bodies.length) {\n                let item = remainingItems[0];\n                remainingItems.splice(0, 1);\n                let variables = {};\n                variables[varName] = item;\n                pack.push({\n                    variables: variables,\n                    activity: bodies[idx++]\n                });\n            }\n            callContext.schedule(pack, \"_bodyFinished\");\n        }\n        else {\n            let item = remainingItems[0];\n            remainingItems.splice(0, 1);\n            let variables = {};\n            variables[varName] = item;\n            callContext.schedule({ activity: this._body, variables: variables }, \"_bodyFinished\");\n        }\n        return;\n    }\n\n    if (iterator) {\n        if (this.parallel) {\n            callContext.fail(new errors.ActivityRuntimeError(\"Parallel execution not supported with generators.\"));\n            return;\n        }\n        else {\n            let next = iterator.next();\n            if (!next.done) {\n                let variables = {};\n                variables[varName] = next.value;\n                callContext.schedule({ activity: this._body, variables: variables }, \"_bodyFinished\");\n                return;\n            }\n        }\n    }\n\n    callContext.complete(lastResult);\n};\n\nForEach.prototype._bodyFinished = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        callContext.activity._doStep.call(this, callContext, result);\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = ForEach;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/merge.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction Merge() {\n    Activity.call(this);\n\n    this.isTrue = true;\n    this.isFalse = false;\n}\n\nutil.inherits(Merge, Activity);\n\nMerge.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nMerge.prototype._argsGot = function (callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    let merged;\n    let mergedIsObj = false;\n    let mergedIsArray = false;\n    for (let item of result) {\n        let isObj = _.isPlainObject(item);\n        let isArray = _.isArray(item);\n        if (isObj || isArray) {\n            if (!merged) {\n                merged = isObj ? _.cloneDeep(item) : item.slice(0);\n                mergedIsObj = isObj;\n                mergedIsArray = isArray;\n            }\n            else if (isObj) {\n                if (!mergedIsObj) {\n                    callContext.fail(new Error(\"Object cannot merged with an array.\"));\n                    return;\n                }\n                _.extend(merged, item);\n            }\n            else {\n                if (!mergedIsArray) {\n                    callContext.fail(new Error(\"Array cannot merged with an object.\"));\n                    return;\n                }\n                for (let sub of item) {\n                    merged.push(sub);\n                }\n            }\n        }\n        else {\n            callContext.fail(new Error(\"Only objects and arrays could be merged.\"));\n            return;\n        }\n    }\n    callContext.complete(merged);\n};\n\nmodule.exports = Merge;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/switch.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet Case = require(\"./case\");\nlet When = require(\"./when\");\nlet Default = require(\"./default\");\nlet errors = require(\"../common/errors\");\nlet constants = require(\"../common/constants\");\n\nfunction Switch() {\n    Activity.call(this);\n\n    this.expression = null;\n}\n\nutil.inherits(Switch, Activity);\n\nSwitch.prototype.run = function (callContext, args) {\n    if (args && args.length) {\n        let parts = {\n            cases: [],\n            whens: [],\n            default: null\n        };\n        for (let arg of args) {\n            if (arg instanceof Case) {\n                parts.cases.push(arg);\n            }\n            else if (arg instanceof When) {\n                parts.whens.push(arg);\n            }\n            else if (arg instanceof Default) {\n                if (parts.default === null) {\n                    parts.default = arg;\n                }\n                else {\n                    throw new errors.ActivityRuntimeError(\"Multiple default for a switch is not allowed.\");\n                }\n            }\n        }\n        if (parts.cases.length || parts.whens.length || parts.default) {\n            this._parts = parts;\n            if (parts.cases.length) {\n                this._doCase = true;\n                callContext.schedule(this.expression, \"_expressionGot\");\n            }\n            else {\n                this._doCase = false;\n                callContext.activity._step.call(this, callContext);\n            }\n            return;\n        }\n    }\n    callContext.complete();\n};\n\nSwitch.prototype._expressionGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        this.expression = result;\n        callContext.activity._step.call(this, callContext);\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nSwitch.prototype._step = function (callContext) {\n    let parts = this._parts;\n    let doCase = this._doCase;\n    if (doCase && parts.cases.length) {\n        let next = parts.cases[0];\n        parts.cases.splice(0, 1);\n        callContext.schedule(next, \"_partCompleted\");\n    }\n    else if (!doCase && parts.whens.length) {\n        let next = parts.whens[0];\n        parts.whens.splice(0, 1);\n        callContext.schedule(next, \"_partCompleted\");\n    }\n    else if (parts.default) {\n        callContext.schedule(parts.default, \"_partCompleted\");\n    }\n    else {\n        callContext.complete();\n    }\n};\n\nSwitch.prototype._partCompleted = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        if (result === constants.markers.nope) {\n            callContext.activity._step.call(this, callContext);\n        }\n        else {\n            callContext.complete(result);\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = Switch;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/case.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet constants = require(\"../common/constants\");\nlet WithBody = require(\"./withBody\");\n\nfunction Case() {\n    WithBody.call(this);\n\n    this.value = null;\n}\n\nutil.inherits(Case, WithBody);\n\nCase.prototype.run = function (callContext, args) {\n    callContext.schedule(this.value, \"_valueGot\");\n};\n\nCase.prototype._valueGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        if (this.expression === result) {\n            WithBody.prototype.run.call(this, callContext);\n        }\n        else {\n            callContext.complete(constants.markers.nope);\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = Case;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/when.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet constants = require(\"../common/constants\");\nlet WithBody = require(\"./withBody\");\n\nfunction When() {\n    WithBody.call(this);\n\n    this.condition = null;\n}\n\nutil.inherits(When, WithBody);\n\nWhen.prototype.run = function (callContext, args) {\n    callContext.schedule(this.condition, \"_conditionGot\");\n};\n\nWhen.prototype._conditionGot = function (callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        if (result) {\n            WithBody.prototype.run.call(this, callContext);\n        }\n        else {\n            callContext.complete(constants.markers.nope);\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = When;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/default.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet WithBody = require(\"./withBody\");\n\nfunction Default() {\n    WithBody.call(this);\n}\n\nutil.inherits(Default, WithBody);\n\nmodule.exports = Default;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/console.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction Console() {\n    Activity.call(this);\n\n    this.level = \"log\";\n}\n\nutil.inherits(Console, Activity);\n\nConsole.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nConsole.prototype._argsGot = function(callContext, reason, result) {\n    if (reason === Activity.states.complete) {\n        let f = console.log;\n        switch (this.level) {\n            case \"error\":\n                f = console.error;\n                break;\n            case \"warn\":\n                f = console.warn;\n                break;\n            case \"info\":\n                f = console.info;\n                break;\n        }\n        f.apply(console, result);\n        callContext.complete();\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = Console;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/obj.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction Obj() {\n    Activity.call(this);\n}\n\nutil.inherits(Obj, Activity);\n\nObj.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nObj.prototype._argsGot = function (callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    let obj;\n    if (result.length > 1) {\n        obj = {};\n        obj[result[0]] = result[1];\n    }\n    callContext.complete(obj);\n};\n\nmodule.exports = Obj;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/delayTo.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet Composite = require(\"./composite\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet specStrings = require(\"../common/specStrings\");\nlet errors = require(\"../common/errors\");\nlet assert = require(\"assert\");\nlet Bluebird = require(\"bluebird\");\n\nfunction DelayTo() {\n    Composite.call(this);\n\n    this.to = null;\n    this._inHost = false;\n}\n\nutil.inherits(DelayTo, Composite);\n\nDelayTo.prototype.createImplementation = function (execContext) {\n    assert(!!execContext);\n    let methodName = specStrings.hosting.createDelayToMethodName(this.instanceId);\n    return {\n        \"@block\": {\n            inHost: \"= this.$parent._inHost\",\n            delayTo: \"= this.$parent.to\",\n            args: {\n                \"@if\": {\n                    condition: \"= this.inHost\",\n                    then: {\n                        \"@block\": {\n                            v: null,\n                            done: false,\n                            args: [\n                                {\n                                    \"@if\": {\n                                        condition: \"= _.isDate(this.delayTo)\",\n                                        then: [\n                                            {\n                                                \"@while\": {\n                                                    condition: \"= !this.done\",\n                                                    args: [\n                                                        {\n                                                            \"@beginMethod\": {\n                                                                methodName: methodName,\n                                                                instanceIdPath: \"[0]\",\n                                                                \"@to\": \"v\"\n                                                            }\n                                                        },\n                                                        {\n                                                            \"@if\": {\n                                                                condition: \"= this.v[1].getTime() === this.delayTo.getTime()\",\n                                                                then: {\n                                                                    \"@assign\": {\n                                                                        to: \"done\",\n                                                                        value: true\n                                                                    }\n                                                                }\n                                                            }\n                                                        },\n                                                        {\n                                                            \"@endMethod\": {\n                                                                methodName: methodName\n                                                            }\n                                                        }\n                                                    ]\n                                                }\n                                            }\n                                        ]\n                                    }\n                                }\n                            ]\n                        }\n                    },\n                    else: function() {\n                        if (this.delayTo && _.isDate(this.delayTo)) {\n                            let ms = this.delayTo - new Date();\n                            if (ms < 0) {\n                                ms = 0;\n                            }\n                            if (ms) {\n                                return Bluebird.delay(ms);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n};\n\nDelayTo.prototype.run = function(callContext, args) {\n    this._inHost = !!callContext.executionContext.engine.instance;\n    Composite.prototype.run.call(this, callContext, args);\n};\n\nmodule.exports = DelayTo;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/delay.js":"\"use strict\";\nlet Activity = require(\"./activity\");\nlet Composite = require(\"./composite\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nrequire(\"date-utils\");\n\nfunction Delay() {\n    Composite.call(this);\n\n    this.ms = null;\n}\n\nutil.inherits(Delay, Composite);\n\nDelay.prototype.createImplementation = function (execContext) {\n    return {\n        \"@delayTo\": {\n            to: \"= new Date().addMilliseconds(this.$parent.ms || 0)\"\n        }\n    };\n};\n\nmodule.exports = Delay;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/repeat.js":"\"use strict\";\nlet Activity = require(\"./activity\");\nlet Composite = require(\"./composite\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nrequire(\"date-utils\");\nlet timespan = require(\"timespan\");\nlet TimeSpan = timespan.TimeSpan;\nlet debug = require(\"debug\")(\"wf4node:Repeat\");\n\nfunction Repeat() {\n    Composite.call(this);\n\n    this.startOn = null;\n    this.intervalType = null;\n    this.intervalValue = null;\n    this.nextPropName = \"next\";\n}\n\nRepeat.intervalTypes = {\n    secondly: \"secondly\",\n    minutely: \"minutely\",\n    hourly: \"hourly\",\n    daily: \"daily\",\n    weekly: \"weekly\"\n};\n\nutil.inherits(Repeat, Composite);\n\nRepeat.prototype.createImplementation = function (execContext) {\n    let args = this.args;\n    this.args = null;\n    return {\n        \"@block\": {\n            startOn: \"= this.$parent.startOn || (new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate()))\",\n            intervalType: `= this.$parent.intervalType || '${Repeat.intervalTypes.daily}'`,\n            intervalValue: \"= this.$parent.intervalValue || 1\",\n            next: null,\n            args: [\n                {\n                    \"@assign\": {\n                        to: \"next\",\n                        value: \"= this.startOn\"\n                    }\n                },\n                {\n                    \"@while\": {\n                        condition: true,\n                        args: [\n                            function () {\n                                debug(\"Delaying to: %s\", this.next);\n                            },\n                            {\n                                \"@delayTo\": {\n                                    to: \"= this.next\"\n                                }\n                            },\n                            function () {\n                                debug(\"Delayed to: %s. Running arguments.\", new Date());\n                            },\n                            {\n                                \"@block\": args\n                            },\n                            {\n                                \"@assign\": {\n                                    to: \"next\",\n                                    value: function () {\n                                        let self = this;\n                                        let now = new Date();\n                                        let next = this.next;\n                                        debug(\"Calculating next's value from: %s. intervalType: %s, intervalValue: %d\", next.getTime(), self.intervalType, self.intervalValue);\n                                        let value = self.intervalValue;\n                                        switch (self.intervalType) {\n                                            case \"secondly\":\n                                                next = next.add({ milliseconds: value * 1000 });\n                                                break;\n                                            case \"minutely\":\n                                                next = next.add({ minutes: value });\n                                                break;\n                                            case \"hourly\":\n                                                next = next.add({ hours: value });\n                                                break;\n                                            case \"weekly\":\n                                                next = next.add({ weeks: value });\n                                                break;\n                                            default:\n                                                next = next.add({ days: value });\n                                                break;\n                                        }\n                                        debug(\"New next is: %s\", next.getTime());\n                                        if (next.getTime() > now.getTime()) {\n                                            debug(\"That's a future value, returning.\");\n                                            // If this is in the future, then we're done:\n                                            return next;\n                                        }\n                                        else {\n                                            debug(\"That's a past value, calculating future value by adding periods.\");\n                                            let dSec = (now - next) / 1000.0;\n                                            debug(\"Total distance in seconds: %d\", dSec);\n                                            let interval;\n                                            switch (self.intervalType) {\n                                                case \"secondly\":\n                                                    interval = timespan.fromSeconds(self.intervalValue);\n                                                    break;\n                                                case \"minutely\":\n                                                    interval = timespan.fromMinutes(self.intervalValue);\n                                                    break;\n                                                case \"hourly\":\n                                                    interval = timespan.fromHours(self.intervalValue);\n                                                    break;\n                                                case \"weekly\":\n                                                    interval = timespan.fromDays(self.intervalValue * 7);\n                                                    break;\n                                                default:\n                                                    interval = timespan.fromDays(self.intervalValue);\n                                                    break;\n                                            }\n                                            interval = interval.totalSeconds();\n                                            debug(\"Interval in seconds: %d\", interval);\n                                            let mod = dSec % interval;\n                                            debug(\"Remainder is: %d\", mod);\n                                            let toAdd = interval - mod;\n                                            debug(\"To add to now is: %d\", toAdd);\n                                            let result = now.add({ seconds: toAdd });\n                                            debug(\"Result is: %s\", result.getTime());\n                                            return result;\n                                        }\n                                    }\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    };\n};\n\nmodule.exports = Repeat;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/try.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\nlet _ = require(\"lodash\");\nlet Block = require(\"./block\");\n\nfunction Try() {\n    Activity.call(this);\n\n    this.arrayProperties.add(\"catch\");\n    this.arrayProperties.add(\"finally\");\n    this.nonScopedProperties.add(\"continueAfterFinally\");\n\n    this.varName = \"e\";\n    this._body = null;\n    this.catch = null;\n    this.finally = null;\n}\n\nutil.inherits(Try, Activity);\n\nTry.prototype.initializeStructure = function() {\n    this._body = new Block();\n    this._body.args = this.args;\n    this.args = null;\n    if (this.catch) {\n        let prev = this.catch;\n        this.catch = new Block();\n        this.catch.args = prev;\n    }\n    if (this.finally) {\n        let prev = this.finally;\n        this.finally = new Block();\n        this.finally.args = prev;\n    }\n};\n\nTry.prototype.run = function (callContext, args) {\n    callContext.schedule(this._body, \"_bodyFinished\");\n};\n\nTry.prototype._bodyFinished = function(callContext, reason, result) {\n    if (this.catch || this.finally) {\n        this._originalResult = result;\n        this._originalReason = reason;\n        if (reason === Activity.states.fail && !(result instanceof errors.ActivityRuntimeError) && this.catch) {\n            this[this.varName] = result;\n            this.Try_ReThrow = false;\n            callContext.schedule(this.catch, \"_catchDone\");\n            return;\n        }\n        else if ((reason === Activity.states.fail || reason === Activity.states.complete) && this.finally) {\n            callContext.schedule(this.finally, \"_finallyDone\");\n            return;\n        }\n    }\n    callContext.end(reason, result);\n};\n\nTry.prototype._catchDone = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    this._catchResult = result;\n    if (this.finally) {\n        callContext.schedule(this.finally, \"_finallyDone\");\n    }\n    else {\n        callContext.activity.continueAfterFinally.call(this, callContext);\n    }\n};\n\nTry.prototype._finallyDone = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    callContext.activity.continueAfterFinally.call(this, callContext);\n};\n\nTry.prototype.continueAfterFinally = function(callContext) {\n    let reason = this._originalReason;\n    let result = this._originalResult;\n    if (reason === Activity.states.fail && !_.isUndefined(this.Try_ReThrow)) {\n        // We've came from a catch:\n        if (this.Try_ReThrow === true) {\n            callContext.fail(result);\n        }\n        else if (this.Try_ReThrow instanceof Error) {\n            callContext.fail(this.Try_ReThrow);\n        }\n        else {\n            callContext.complete(this._catchResult);\n        }\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = Try;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/throw.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\nlet _ = require(\"lodash\");\n\nfunction Throw() {\n    Activity.call(this);\n\n    this.error = null;\n}\n\nutil.inherits(Throw, Activity);\n\nThrow.prototype.run = function (callContext, args) {\n    if (!this.error) {\n        if (!_.isUndefined(this.Try_ReThrow)) {\n            this.Try_ReThrow = true;\n        }\n        callContext.complete();\n    }\n    else {\n        callContext.schedule(this.error, \"_errorGot\");\n    }\n};\n\nThrow.prototype._errorGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    let e;\n    if (_.isString(result)) {\n        e = new Error(result);\n    }\n    else if (result instanceof Error) {\n        e = result;\n    }\n    else {\n        callContext.complete();\n        return;\n    }\n\n    if (!_.isUndefined(this.Try_ReThrow)) {\n        this.Try_ReThrow = e;\n        callContext.complete();\n    }\n    else {\n        callContext.fail(e);\n    }\n};\n\nmodule.exports = Throw;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/emit.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\n\nfunction Emit() {\n    Activity.call(this);\n}\n\nutil.inherits(Emit, Activity);\n\nEmit.prototype.run = function (callContext, args) {\n    callContext.schedule(args, \"_argsGot\");\n};\n\nEmit.prototype._argsGot = function(callContext, reason, result) {\n    if (reason !== Activity.states.complete) {\n        callContext.end(reason, result);\n        return;\n    }\n\n    if (result && result.length) {\n        callContext.emitWorkflowEvent(result);\n    }\n\n    callContext.complete();\n};\n\nmodule.exports = Emit;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/cancel.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\n\nfunction Cancel() {\n    Activity.call(this);\n\n    this.force = false;\n}\n\nutil.inherits(Cancel, Activity);\n\nCancel.prototype.run = function(callContext, args) {\n    if (this.force) {\n        callContext.fail(new errors.Cancelled());\n    }\n    else {\n        callContext.cancel();\n    }\n};\n\nmodule.exports = Cancel;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/cancellationScope.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\nlet errors = require(\"../common/errors\");\nlet Block = require(\"./block\");\n\nfunction CancellationScope() {\n    Activity.call(this);\n\n    this.cancelled = null;\n    this.arrayProperties.add(\"cancelled\");\n}\n\nutil.inherits(CancellationScope, Activity);\n\nCancellationScope.prototype.initializeStructure = function () {\n    this._body = new Block();\n    this._body.args = this.args;\n    this.args = null;\n    if (this.cancelled) {\n        let prev = this.cancelled;\n        this.cancelled = new Block();\n        this.cancelled.args = prev;\n    }\n};\n\nCancellationScope.prototype.run = function (callContext, args) {\n    callContext.schedule(this._body, \"_bodyFinished\");\n};\n\nCancellationScope.prototype._bodyFinished = function (callContext, reason, result) {\n    if (this.cancelled &&\n        (reason === Activity.states.cancel ||\n         (reason === Activity.states.fail && result instanceof errors.Cancelled))) {\n        callContext.schedule(this.cancelled);\n    }\n    else {\n        callContext.end(reason, result);\n    }\n};\n\nmodule.exports = CancellationScope;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/activities/instanceData.js":"\"use strict\";\n\nlet Activity = require(\"./activity\");\nlet util = require(\"util\");\n\nfunction InstanceData() {\n    Activity.call(this);\n}\n\nutil.inherits(InstanceData, Activity);\n\nInstanceData.prototype.run = function(callContext, args) {\n    if (callContext.executionContext.engine && callContext.executionContext.engine.instance) {\n        let insta = callContext.executionContext.engine.instance;\n        callContext.complete({\n            workflowName: insta.workflowName,\n            workflowVersion: insta.workflowVersion,\n            instanceId: insta.id\n        });\n    }\n    else {\n        callContext.complete(null);\n    }\n};\n\nmodule.exports = InstanceData;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/index.js":"module.exports = {\n    InstanceIdParser: require(\"./instanceIdParser\"),\n    WorkflowHost: require(\"./workflowHost\"),\n    MemoryPersistence: require(\"./memoryPersistence\")\n};\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/instanceIdParser.js":"/* jshint -W054*/\n\"use strict\";\n\nlet _ = require(\"lodash\");\nlet is = require(\"../common/is\");\n\nfunction InstanceIdParser() {\n    this._cache = {};\n}\n\nInstanceIdParser.prototype.parse = function (path, obj) {\n    if (!obj) {\n        throw new Error(\"Argument 'obj' expected.\");\n    }\n    if (!_.isString(path)) {\n        throw new TypeError(\"Argument 'path' is not a string.\");\n    }\n\n    let parser = this._cache[path];\n    if (_.isUndefined(parser)) {\n        this._cache[path] = parser = this._createParser(path);\n    }\n\n    return parser.call(obj);\n};\n\nInstanceIdParser.prototype._createParser = function (path) {\n    if (path.indexOf(\"this\") !== 0) {\n        if (path[0] === \"[\") {\n            path = \"this\" + path;\n        }\n        else {\n            path = \"this.\" + path;\n        }\n    }\n\n    return new Function(\"return (\" + path + \").toString();\");\n};\n\nmodule.exports = InstanceIdParser;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/workflowHost.js":"\"use strict\";\n\nlet WorkflowRegistry = require(\"./workflowRegistry\");\nlet _ = require(\"lodash\");\nlet Activity = require(\"../activities/activity\");\nlet Workflow = require(\"../activities/workflow\");\nlet WorkflowPersistence = require(\"./workflowPersistence\");\nlet WorkflowInstance = require(\"./workflowInstance\");\nlet InstanceIdParser = require(\"./instanceIdParser\");\nlet enums = require(\"../common/enums\");\nlet Bluebird = require(\"bluebird\");\nlet KnownInstaStore = require(\"./knownInstaStore\");\nlet specStrings = require(\"../common/specStrings\");\nlet errors = require(\"../common/errors\");\nlet Serializer = require(\"backpack-node\").system.Serializer;\nlet is = require(\"../common/is\");\nlet KeepLockAlive = require(\"./keepLockAlive\");\nlet asyncHelpers = require(\"../common/asyncHelpers\");\nlet async = asyncHelpers.async;\nlet WakeUp = require(\"./wakeUp\");\nlet assert = require(\"assert\");\nlet debug = require(\"debug\")(\"wf4node:WorkflowHost\");\nlet EventEmitter = require(\"events\").EventEmitter;\nlet util = require(\"util\");\n\nfunction WorkflowHost(options) {\n    EventEmitter.call(this);\n\n    this._options = _.extend(\n        {\n            enterLockTimeout: 10000,\n            lockRenewalTimeout: 5000,\n            alwaysLoadState: false,\n            lazyPersistence: true,\n            persistence: null,\n            serializer: null,\n            enablePromotions: false,\n            wakeUpOptions: {\n                interval: 5000,\n                batchSize: 10\n            }\n        },\n        options);\n\n    this._registry = new WorkflowRegistry(this._options.serializer);\n    this._trackers = [];\n    this._isInitialized = false;\n    this._instanceIdParser = new InstanceIdParser();\n    this._persistence = null;\n\n    if (this._options.persistence !== null) {\n        this._persistence = new WorkflowPersistence(this._options.persistence);\n    }\n    this._knownRunningInstances = new KnownInstaStore();\n    this._wakeUp = null;\n    this._shutdown = false;\n}\n\nutil.inherits(WorkflowHost, EventEmitter);\n\nWorkflowHost.events = enums.workflowEvents;\n\nWorkflowHost.prototype.onWorkflowEvent = function (args) {\n    this.emit(WorkflowHost.events.workflowEvent, args);\n};\n\nWorkflowHost.prototype.onWarn = function (error) {\n    this.emit(WorkflowHost.events.warn, error);\n};\n\nWorkflowHost.prototype.onStart = function (instance, methodName, args) {\n    this.emit(WorkflowHost.events.start, {\n        instance: instance,\n        methodName: methodName,\n        args: args\n    });\n};\n\nWorkflowHost.prototype.onInvoke = function (instance, methodName, args, result, idle, error) {\n    this.emit(WorkflowHost.events.invoke, {\n        instance: instance,\n        methodName: methodName,\n        args: args,\n        idle: idle,\n        error: error\n    });\n};\n\nWorkflowHost.prototype.onEnd = function (instance, result, cancelled, error) {\n    this.emit(WorkflowHost.events.end, {\n        instance: instance,\n        result: result,\n        cancelled: cancelled,\n        error: error\n    });\n};\n\nObject.defineProperties(\n    WorkflowHost.prototype, {\n        options: {\n            get: function () {\n                return this._options;\n            }\n        },\n        isInitialized: {\n            get: function () {\n                return this._isInitialized;\n            }\n        },\n        instanceIdParser: {\n            get: function () {\n                return this._instanceIdParser;\n            }\n        },\n        persistence: {\n            get: function () {\n                return this._persistence;\n            }\n        },\n        _inLockTimeout: {\n            get: function () {\n                return this.options.lockRenewalTimeout + Math.max(this.options.lockRenewalTimeout * 0.4, 3000);\n            }\n        }\n    });\n\nWorkflowHost.prototype.registerDeprecatedWorkflow = function (workflow) {\n    return this.registerWorkflow(workflow, true);\n};\n\nWorkflowHost.prototype.registerWorkflow = function (workflow, deprecated) {\n    this._verify();\n    let desc = this._registry.register(workflow, deprecated);\n    debug(\"Workflow registered. name: %s, version: %s\", desc.name, desc.version);\n    return desc.version;\n};\n\nWorkflowHost.prototype._initialize = function () {\n    let self = this;\n    if (!this._isInitialized) {\n        if (this._options.wakeUpOptions && this._options.wakeUpOptions.interval > 0) {\n            this._wakeUp = new WakeUp(this._knownRunningInstances, this._persistence, this._options.wakeUpOptions);\n            this._wakeUp.on(\"continue\", function (i) { self._continueWokeUpInstance(i); });\n            this._wakeUp.on(\"error\", function (e) { self.onWarn(e); });\n            this._wakeUp.start();\n        }\n\n        this._isInitialized = true;\n    }\n};\n\nWorkflowHost.prototype.stop = async(function*(workflowName, instanceId) {\n    let self = this;\n    let remove = function (instanceId) {\n        let knownInsta = self._knownRunningInstances.get(workflowName, instanceId);\n        if (knownInsta) {\n            debug(\"Removing instance: %s\", instanceId);\n            self._deleteWFInstance(knownInsta);\n            self.onEnd(knownInsta, undefined, true);\n        }\n    };\n\n    debug(\"Stopping workflow '%s' with id: '%s'.\", workflowName, instanceId);\n\n    try {\n        if (this._persistence) {\n            let lockName = specStrings.hosting.doubleKeys(workflowName, instanceId);\n            let lockInfo;\n            debug(\"Locking instance: %s\", instanceId);\n            lockInfo = yield (this._persistence.enterLock(lockName, this.options.enterLockTimeout, this._inLockTimeout));\n            let keepLockAlive = null;\n            try {\n                debug(\"Locked: %j\", lockInfo);\n                keepLockAlive = new KeepLockAlive(this._persistence, lockInfo, this._inLockTimeout, this.options.lockRenewalTimeout);\n\n                // Do stuff:\n                yield this._persistence.removeState(workflowName, instanceId, false, \"STOPPED.\");\n                remove(instanceId);\n\n                debug(\"Removed: %s\", instanceId);\n            }\n            catch (e) {\n                debug(\"Error: %s\", e.stack);\n                throw e;\n            }\n            finally {\n                // Unlock:\n                debug(\"Unlocking.\");\n                if (keepLockAlive) {\n                    keepLockAlive.end();\n                }\n                yield this._persistence.exitLock(lockInfo.id);\n            }\n        }\n        else {\n            remove(instanceId);\n        }\n    }\n    catch (e) {\n        debug(\"Error: %s\", e.stack);\n        throw new errors.WorkflowError(`Cannot stop instance of workflow '${workflowName}' with id: '${instanceId}' because of an internal error:\\n${e.stack}`);\n    }\n});\n\nWorkflowHost.prototype.stopDeprecatedVersions = async(function* (workflowName) {\n    this._verify();\n    debug(\"Stopping outdated versions of workflow '%s'.\", workflowName);\n\n\n\n    let count = 0;\n    let currentVersion = this._registry.getCurrentVersion(workflowName);\n    if (currentVersion) {\n        let oldVersionHeaders = yield this._getRunningInstanceHeadersForOtherVersion(workflowName, currentVersion);\n        if (oldVersionHeaders.length) {\n            debug(\"There is %d old version running. Stopping them.\", oldVersionHeaders.length);\n            for (let header of oldVersionHeaders) {\n                debug(\"Stopping workflow '%s' of version '%s' with id: '%s'.\", header.workflowName, header.workflowVersion, header.instanceId);\n                yield this.stop(workflowName, header.instanceId);\n            }\n        }\n    }\n    else {\n        debug(\"There is no workflow registered by name '%s'.\", workflowName);\n    }\n    return count;\n});\n\nWorkflowHost.prototype.invokeMethod = async(function* (workflowName, methodName, args) {\n    this._verify();\n    debug(\"Invoking method: '%s' of workflow: '%s' by arguments '%j'\", workflowName, methodName, args);\n\n    if (!_(workflowName).isString()) {\n        throw new TypeError(\"Argument 'workflowName' is not a string.\");\n    }\n    workflowName = workflowName.trim();\n    if (!_(methodName).isString()) {\n        throw new TypeError(\"Argument 'methodName' is not a string.\");\n    }\n    methodName = methodName.trim();\n\n    if (!_.isUndefined(args) && !_.isArray(args)) {\n        args = [args];\n    }\n\n    let self = this;\n\n    self._initialize();\n\n    let instanceId = null;\n    let creatable = null;\n\n    let results = [];\n    for (let info of self._registry.methodInfos(workflowName, methodName)) {\n        let tryId = self._instanceIdParser.parse(info.instanceIdPath, args);\n        if (!_.isUndefined(tryId)) {\n            results.push(\n                {\n                    info: info,\n                    id: tryId\n                });\n        }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n        debug(\"Possible methods: %j\",\n            _(results)\n                .map(function (r) {\n                    return {\n                        workflow: {\n                            name: r.info.execContext.rootActivity.name,\n                            version: r.info.version\n                        },\n                        id: r.id\n                    };\n                })\n                .toArray());\n    }\n\n    for (let i = 0; i < results.length; i++) {\n        let result = results[i];\n        // That finds the latest version:\n        if (result.info.canCreateInstance && !result.info.deprecated) {\n            creatable = result.info;\n        }\n        // That finds a running instance with the id:\n        if (_.isNull(instanceId) && (yield self._checkIfInstanceRunning(workflowName, result.id))) {\n            instanceId = result.id;\n            break;\n        }\n    }\n\n    if (instanceId) {\n        debug(\"Found a continuable instance id: %s. Invoking method on that.\", instanceId);\n        try {\n            let ir = yield (self._invokeMethodOnRunningInstance(instanceId, workflowName, methodName, args));\n            debug(\"Invoke completed, result: %j\", ir);\n            return ir;\n        }\n        catch (e) {\n            debug(\"Invoke failed: %s\", e.stack);\n            throw e;\n        }\n    }\n    else if (creatable) {\n        debug(\"Found a creatable workflow (name: '%s', version: '%s'), invoking a create method on that.\", creatable.execContext.rootActivity.name, creatable.version);\n        try {\n            let cr = yield (self._createInstanceAndInvokeMethod(creatable.execContext, creatable.version, methodName, args));\n            debug(\"Create completed, result: %j\", cr);\n            return cr;\n        }\n        catch (e) {\n            debug(\"Create failed: %s\", e.stack);\n            throw e;\n        }\n    }\n    else {\n        debug(\"No continuable workflows have been found.\");\n        throw new errors.MethodNotFoundError(\"Cannot create or continue workflow '\" + workflowName + \"' by calling method '\" + methodName + \"'.\");\n    }\n});\n\nWorkflowHost.prototype._createInstanceAndInvokeMethod = async(function* (execContext, workflowVersion, methodName, args) {\n    let workflowName = execContext.rootActivity.name;\n\n    let lockInfo = null;\n\n    if (!this._persistence) {\n        let insta = this._createWFInstance();\n        let result = yield (insta.create(execContext, workflowVersion, methodName, args, lockInfo));\n        this._knownRunningInstances.add(workflowName, insta);\n        this.onStart(insta, methodName, args);\n        return result;\n    }\n    else {\n        lockInfo = {\n            id: null,\n            name: null,\n            heldTo: null\n        };\n        // When lock will held, then we should keep it alive:\n        let keepLockAlive = new KeepLockAlive(this._persistence, lockInfo, this._inLockTimeout, this.options.lockRenewalTimeout);\n        try {\n            let insta = this._createWFInstance();\n            let result = yield (insta.create(execContext, workflowVersion, methodName, args, lockInfo));\n\n            if (insta.execState === enums.activityStates.idle) {\n                this._knownRunningInstances.add(workflowName, insta);\n\n                // Persist and unlock:\n                let err = null;\n                try {\n                    yield this._persistence.persistState(insta);\n                    this.onStart(insta, methodName, args);\n                }\n                catch (e) {\n                    debug(\"Cannot persist instance of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                    this._knownRunningInstances.remove(workflowName, insta.id);\n                    err = e;\n                }\n                try {\n                    yield this._persistence.exitLock(lockInfo.id);\n                }\n                catch (e) {\n                    debug(\"Cannot exit lock of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                    this.onWarn(e);\n                }\n                if (err) {\n                    throw err;\n                }\n\n                return result;\n            }\n            else {\n                return result;\n            }\n        }\n        finally {\n            keepLockAlive.end();\n        }\n    }\n});\n\nWorkflowHost.prototype._throwIfRecoverable = function (error, workflowName, methodName) {\n    if (error instanceof errors.MethodIsNotAccessibleError) {\n        debug(\"Method '%s' of workflow '%s' is not accessible at the current state, bacause it might be stepped on another instance to another state tha is exists at current in this host. Client should retry.\", methodName, workflowName);\n        throw error;\n    }\n};\n\nWorkflowHost.prototype._invokeMethodOnRunningInstance = async(function* (instanceId, workflowName, methodName, args) {\n    let self = this;\n\n    if (!self._persistence) {\n        let insta = yield (self._verifyAndRestoreInstanceState(instanceId, workflowName, methodName, args));\n        try {\n            let result = yield (insta.callMethod(methodName, args));\n            if (insta.execState === enums.activityStates.idle) {\n                this.onInvoke(insta, methodName, args, result, true, null);\n                return result;\n            }\n            else if (insta.execState === enums.activityStates.complete) {\n                self._deleteWFInstance(insta);\n                this.onInvoke(insta, methodName, args, result, false, null);\n                this.onEnd(insta, result, false, null);\n                return result;\n            }\n            else {\n                throw new errors.WorkflowError(\"Instance '\" + insta.id + \"' is in an invalid state '\" + insta.execState + \"' after invocation of the method '\" + methodName + \"'.\");\n            }\n        }\n        catch (e) {\n            this._throwIfRecoverable(e, workflowName, methodName);\n            self._deleteWFInstance(insta);\n            this.onInvoke(insta, methodName, args, undefined, false, e);\n            this.onEnd(insta, undefined, false, e);\n            throw e;\n        }\n    }\n    else {\n        // Lock it:\n        let lockName = specStrings.hosting.doubleKeys(workflowName, instanceId);\n        let lockInfo;\n        let keepLockAlive = null;\n        try {\n            debug(\"Locking instance.\");\n            lockInfo = yield (self._persistence.enterLock(lockName, self.options.enterLockTimeout, self._inLockTimeout));\n            debug(\"Locked: %j\", lockInfo);\n\n            // When lock will held, then we should keep it alive:\n            keepLockAlive = new KeepLockAlive(self._persistence, lockInfo, self._inLockTimeout, self.options.lockRenewalTimeout);\n\n            // LOCKED\n            let insta = yield (self._verifyAndRestoreInstanceState(instanceId, workflowName, methodName, args));\n            let endWithError = async(function*(e) {\n                self._deleteWFInstance(insta);\n                try {\n                    yield (self._persistence.removeState(workflowName, insta.id, false, e));\n                }\n                catch (removeE) {\n                    debug(\"Cannot remove state of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + removeE.stack);\n                    self.onWarn(removeE);\n                }\n                self.onInvoke(insta, methodName, args, undefined, false, e);\n                self.onEnd(insta, undefined, false, e);\n            });\n            try {\n                let persistAndUnlock = function () {\n                    return self._persistence.persistState(insta)\n                        .finally(function () {\n                            debug(\"Unlocking: %j\", lockInfo);\n                            return self._persistence.exitLock(lockInfo.id)\n                                .then(function () {\n                                    debug(\"Unlocked.\");\n                                },\n                                function (e) {\n                                    debug(\"Cannot exit lock for workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                                    self.onWarn(e);\n                                })\n                                .finally(function () {\n                                    keepLockAlive.end();\n                                });\n                        });\n                };\n                let result = yield (insta.callMethod(methodName, args));\n                if (insta.execState === enums.activityStates.idle) {\n                    // Persist and unlock:\n                    if (self.options.lazyPersistence) {\n                        setImmediate(function () {\n                            persistAndUnlock()\n                                .then(function () {\n                                    self.onInvoke(insta, methodName, args, result, true, null);\n                                },\n                                function(e) {\n                                    endWithError(e);\n                                });\n                        });\n                    }\n                    else {\n                        yield persistAndUnlock();\n                        this.onInvoke(insta, methodName, args, result, true, null);\n                    }\n\n                    return result;\n                }\n                else if (insta.execState === enums.activityStates.complete) {\n                    self._deleteWFInstance(insta);\n                    this.onInvoke(insta, methodName, args, result, false, null);\n                    this.onEnd(insta, result, false, null);\n                    try {\n                        try {\n                            yield self._persistence.removeState(workflowName, insta.id, true);\n                        }\n                        catch (e) {\n                            debug(\"Cannot remove state of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                            this.onWarn(e);\n                        }\n\n                        try {\n                            yield self._persistence.exitLock(lockInfo.id);\n                        }\n                        catch (e) {\n                            debug(\"Cannot exit lock of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                            this.onWarn(e);\n                        }\n                    }\n                    finally {\n                        keepLockAlive.end();\n                    }\n                    return result;\n                }\n                else {\n                    throw new errors.WorkflowError(\"Instance '\" + insta.id + \"' is in an invalid state '\" + insta.execState + \"' after invocation of the method '\" + methodName + \"'.\");\n                }\n            }\n            catch (e) {\n                this._throwIfRecoverable(e, workflowName, methodName);\n                yield endWithError(e);\n                throw e;\n            }\n        }\n        catch (e) {\n            if (keepLockAlive) {\n                keepLockAlive.end();\n            }\n            if (lockInfo) {\n                try {\n                    yield self._persistence.exitLock(lockInfo.id);\n                }\n                catch (exitE) {\n                    debug(\"Cannot exit lock '\" + lockInfo.id + \"':\\n\" + exitE.stack);\n                    this.onWarn(exitE);\n                }\n            }\n            if (e instanceof errors.TimeoutError) {\n                let msg = \"Cannot call method of workflow '\" + workflowName + \"', because '\" + methodName + \"' is locked.\";\n                debug(msg);\n                throw new errors.MethodIsNotAccessibleError(msg);\n            }\n            throw e;\n        }\n    }\n});\n\nWorkflowHost.prototype._enterLockForCreatedInstance = async(function* (insta, lockInfo) {\n    let li = yield (this._persistence.enterLock(specStrings.hosting.doubleKeys(insta.workflowName, insta.id), this.options.enterLockTimeout, this._getInLockTimeout()));\n    if (yield (this._persistence.isRunning(insta.workflowName, insta.id))) {\n        throw new errors.WorkflowError(\"Cannot create instance of workflow '\" + insta.workflowName + \"' by id '\" + insta.id + \"' because it's already exists.\");\n    }\n    lockInfo.id = li.id;\n    lockInfo.name = li.name;\n    lockInfo.heldTo = li.heldTo;\n});\n\nWorkflowHost.prototype._getInLockTimeout = function () {\n    return this.options.lockRenewalTimeout + Math.max(this.options.lockRenewalTimeout * 0.4, 3000);\n};\n\nWorkflowHost.prototype._verifyAndRestoreInstanceState = async(function* (instanceId, workflowName, methodName, args) {\n    let self = this;\n    let insta = null;\n    if (self._persistence) {\n        let header = yield (self._persistence.getRunningInstanceIdHeader(workflowName, instanceId));\n        if (header) {\n            insta = yield (self._restoreInstanceState(instanceId, workflowName, header.workflowVersion, header.updatedOn));\n        }\n    }\n    else {\n        insta = self._knownRunningInstances.get(workflowName, instanceId);\n    }\n    if (!insta) {\n        throw new errors.WorkflowNotFoundError(`Worflow (name: '${workflowName}', id: '${instanceId}') has been deleted since the lock has been taken.`);\n    }\n\n    return insta;\n});\n\nWorkflowHost.prototype._restoreInstanceState = async(function* (instanceId, workflowName, workflowVersion, actualTimestamp) {\n    let self = this;\n\n    if (!self._persistence) {\n        throw new Error(\"Cannot restore instance from persistence, because host has no persistence registered.\");\n    }\n\n    let insta = self._knownRunningInstances.get(workflowName, instanceId);\n    if (_.isUndefined(insta)) {\n        let wfDesc = self._registry.getDesc(workflowName, workflowVersion);\n        insta = self._createWFInstance();\n        insta.setWorkflow(wfDesc.execContext, workflowVersion, instanceId);\n    }\n\n    if (insta.updatedOn === null || insta.updatedOn.getTime() !== actualTimestamp.getTime() || self.options.alwaysLoadState) {\n        let state = yield (self._persistence.loadState(workflowName, instanceId));\n        insta.restoreState(state);\n        return insta;\n    }\n    else {\n        return insta;\n    }\n});\n\nWorkflowHost.prototype._checkIfInstanceRunning = async(function* (workflowName, instanceId) {\n    if (this._persistence) {\n        return (yield this._persistence.isRunning(workflowName, instanceId));\n    }\n    return this._knownRunningInstances.exists(workflowName, instanceId);\n});\n\nWorkflowHost.prototype._getRunningInstanceHeadersForOtherVersion = async(function* (workflowName, version) {\n    if (this._persistence) {\n        return (yield this._persistence.getRunningInstanceHeadersForOtherVersion(workflowName, version));\n    }\n    return this._knownRunningInstances.getRunningInstanceHeadersForOtherVersion(workflowName, version);\n});\n\nWorkflowHost.prototype.addTracker = function (tracker) {\n    this._verify();\n\n    if (!_.isObject(tracker)) {\n        throw new TypeError(\"Argument is not an object.\");\n    }\n    this._trackers.push(tracker);\n    this._knownRunningInstances.addTracker(tracker);\n};\n\n/* Wake Up*/\n\nWorkflowHost.prototype._continueWokeUpInstance = async(function*(wakeupable) {\n    if (this._shutdown) {\n        wakeupable.result.resolve();\n        return;\n    }\n    if (!this._persistence) {\n        wakeupable.result.reject(new errors.WorkflowError(\"Handling Delays in host is not supported without persistence.\"));\n        return;\n    }\n\n    assert(_.isPlainObject(wakeupable));\n    assert(_.isString(wakeupable.instanceId));\n    assert(_.isString(wakeupable.workflowName));\n    assert(_.isPlainObject(wakeupable.activeDelay));\n    assert(_.isString(wakeupable.activeDelay.methodName));\n    assert(_.isDate(wakeupable.activeDelay.delayTo));\n    assert(_.isFunction(wakeupable.result.resolve));\n    assert(_.isFunction(wakeupable.result.reject));\n\n    try {\n        //instanceId, workflowName, methodName, args\n        debug(\"Invoking DelayTo instanceId: %s, workflowName:%s, methodName: %s\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName);\n        let result = yield this._invokeMethodOnRunningInstance(wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName, [wakeupable.instanceId, wakeupable.activeDelay.delayTo]);\n        debug(\"DelayTo instanceId: %s, workflowName:%s, methodName: %s invoked.\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName);\n        wakeupable.result.resolve();\n    }\n    catch (e) {\n        if (e instanceof errors.MethodIsNotAccessibleError || e instanceof errors.WorkflowNotFoundError) {\n            debug(\"DelayTo's method is not accessible since it got selected for continuation.\");\n            wakeupable.result.resolve();\n            return;\n        }\n        debug(\"DelayTo instanceId: %s, workflowName:%s, methodName: %s error: %s\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName, e.stack);\n        wakeupable.result.reject(e);\n    }\n});\n\nWorkflowHost.prototype._createWFInstance = function () {\n    let self = this;\n    let insta = new WorkflowInstance(this);\n    insta.on(\n        enums.events.workflowEvent,\n        function (args) {\n            self.onWorkflowEvent(args);\n        });\n    return insta;\n};\n\nWorkflowHost.prototype._deleteWFInstance = function (insta) {\n    insta.removeAllListeners();\n    this._knownRunningInstances.remove(insta.workflowName, insta.id);\n};\n\n/* Shutdown */\n\nWorkflowHost.prototype._verify = function () {\n    if (this._shutdown) {\n        throw new errors.WorkflowError(\"Workflow host has been shut down.\");\n    }\n};\n\nWorkflowHost.prototype.shutdown = function () {\n    if (this._shutdown) {\n        return;\n    }\n    if (this._wakeUp) {\n        this._wakeUp.stop();\n    }\n    this._shutdown = true;\n    this.removeAllListeners();\n};\n\nmodule.exports = WorkflowHost;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/workflowRegistry.js":"\"use strict\";\n\nlet Workflow = require(\"../activities/workflow\");\nlet _ = require(\"lodash\");\nlet BeginMethod = require(\"../activities/beginMethod\");\nlet EndMethod = require(\"../activities/endMethod\");\nlet is = require(\"../common/is\");\nlet ActivityExecutionContext = require(\"../activities/activityExecutionContext\");\nlet activityMarkup = require(\"../activities/activityMarkup\");\nlet Serializer = require(\"backpack-node\").system.Serializer;\nlet crypto = require(\"crypto\");\nlet assert = require(\"better-assert\");\n\nfunction WorkflowRegistry(serializer) {\n    this._workflows = new Map();\n    this._serializer = serializer || new Serializer();\n}\n\nWorkflowRegistry.prototype.register = function (workflow, deprecated) {\n    if (_.isPlainObject(workflow)) {\n        workflow = activityMarkup.parse(workflow);\n    }\n    if (workflow instanceof Workflow) {\n        if (!_(workflow.name).isString()) {\n            throw new TypeError(\"Workflow name is not a string.\");\n        }\n        let name = workflow.name.trim();\n        if (!name) {\n            throw new TypeError(\"Workflow name is empty.\");\n        }\n        let execContext = new ActivityExecutionContext();\n        execContext.initialize(workflow);\n        let version = this._computeVersion(execContext);\n        let entry = this._workflows.get(name);\n        let desc;\n        if (entry) {\n            desc = entry.get(version);\n            if (desc) {\n                throw new Error(\"Workflow \" + name + \" (\" + version + \") already registered.\");\n            }\n            else {\n                if (!deprecated) {\n                    for (desc of entry.values()) {\n                        if (!desc.deprecated) {\n                            throw new Error(\"Workflow \" + name + \" (\" + version + \") has an already registered undeprecated version.\");\n                        }\n                    }\n                }\n                desc = this._createDesc(execContext, name, version, deprecated);\n                entry.set(version, desc);\n            }\n        }\n        else {\n            entry = new Map();\n            desc = this._createDesc(execContext, name, version, deprecated);\n            entry.set(version, desc);\n            this._workflows.set(name, entry);\n        }\n        return desc;\n    }\n    else {\n        throw new TypeError(\"Workflow instance argument expected.\");\n    }\n};\n\nWorkflowRegistry.prototype.getDesc = function (name, version) {\n    let entry = this._workflows.get(name);\n    if (entry) {\n        if (!_.isUndefined(version)) {\n            let desc = entry.get(version);\n            if (desc) {\n                return desc;\n            }\n            throw new Error(\"Workflow \" + name + \" of version \" + version + \" has not been registered.\");\n        }\n        else {\n            // Get undeprecated\n            let desc = null;\n            for (let d of entry.values()) {\n                if (!d.deprecated) {\n                    desc = d;\n                    break;\n                }\n            }\n            if (desc) {\n                return desc;\n            }\n            throw new Error(\"Workflow \" + name + \" hasn't got an undeprecated version registered.\");\n        }\n    }\n};\n\nWorkflowRegistry.prototype.getCurrentVersion = function (workflowName) {\n    let result = [];\n    let entry = this._workflows.get(workflowName);\n    if (entry) {\n        let desc = null;\n        for (let d of entry.values()) {\n            if (!d.deprecated) {\n                desc = d;\n                break;\n            }\n        }\n        if (desc) {\n            return desc.version;\n        }\n    }\n    return null;\n};\n\nWorkflowRegistry.prototype._createDesc = function (execContext, name, version, deprecated) {\n    return {\n        execContext: execContext,\n        name: name,\n        version: version,\n        methods: this._collectMethodInfos(execContext, version),\n        deprecated: deprecated\n    };\n};\n\nWorkflowRegistry.prototype._collectMethodInfos = function (execContext, version) {\n    let self = this;\n    let infos = new Map();\n    let workflow = execContext.rootActivity;\n    for (let child of workflow.children(execContext)) {\n        let isBM = child instanceof BeginMethod;\n        let isEM = child instanceof EndMethod;\n        if (isBM || isEM) {\n            let methodName = _.isString(child.methodName) ? child.methodName.trim() : null;\n            let instanceIdPath = _.isString(child.instanceIdPath) ? child.instanceIdPath.trim() : null;\n            if (methodName) {\n                let info = infos.get(methodName);\n                if (!info) {\n                    info = {\n                        execContext: execContext,\n                        version: version,\n                        canCreateInstance: false,\n                        instanceIdPath: null\n                    };\n                    infos.set(methodName, info);\n                }\n                if (isBM && child.canCreateInstance) {\n                    info.canCreateInstance = true;\n                }\n                if (instanceIdPath) {\n                    if (info.instanceIdPath) {\n                        if (info.instanceIdPath !== instanceIdPath) {\n                            throw new Error(\"Method '\" + methodName + \"' in workflow '\" + workflow.name + \"' has multiple different instanceIdPath value which is not supported.\");\n                        }\n                    }\n                    else {\n                        info.instanceIdPath = instanceIdPath;\n                    }\n                }\n            }\n        }\n    }\n    let result = new Map();\n    for (let kvp of infos.entries()) {\n        if (kvp[1].instanceIdPath) {\n            result.set(kvp[0], kvp[1]);\n        }\n    }\n    return result;\n};\n\nWorkflowRegistry.prototype.methodInfos = function* (workflowName, methodName) {\n    let entry = this._workflows.get(workflowName);\n    if (entry) {\n        for (let desc of entry.values()) {\n            let info = desc.methods.get(methodName);\n            if (info) {\n                yield info;\n            }\n        }\n    }\n};\n\nWorkflowRegistry.prototype._computeVersion = function(execContext) {\n    let self = this;\n    let workflow = execContext.rootActivity;\n    let sha = crypto.createHash(\"sha256\");\n    function add(value) {\n        if (!_.isNull(value)) {\n            value = self._serializer.stringify(value);\n            sha.update(value);\n        }\n    }\n    for (let activity of workflow.all(execContext)) {\n        let alias = activityMarkup.getAlias(activity);\n        assert(alias);\n        add(alias);\n        for (let key in activity) {\n            if (activity.hasOwnProperty(key) &&\n                !activity.nonScopedProperties.has(key) &&\n                !activity.nonSerializedProperties.has(key)) {\n                let value = activity[key];\n                if (!is.activity(value)) {\n                    if (_.isArray(value)) {\n                        for (let item of value) {\n                            if (!is.activity(item)) {\n                                add(value);\n                            }\n                        }\n                    }\n                    else {\n                        add(value);\n                    }\n                }\n            }\n        }\n    }\n    return sha.digest(\"hex\");\n};\n\nmodule.exports = WorkflowRegistry;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/workflowPersistence.js":"\"use strict\";\n\nlet _ = require(\"lodash\");\nlet WorkflowInstance = require(\"./workflowInstance\");\nlet errors = require(\"../common/errors\");\nlet asyncHelpers = require(\"../common/asyncHelpers\");\nlet Bluebird = require(\"bluebird\");\nlet async = asyncHelpers.async;\nlet assert = require(\"better-assert\");\n\nfunction WorkflowPersistence(impl) {\n    assert(_.isObject(impl));\n\n    this._impl = impl;\n}\n\nWorkflowPersistence.prototype.enterLock = function (lockName, enterLockTimeoutMs, inLockTimeoutMs) {\n    assert(_.isString(lockName));\n    assert(_.isNumber(enterLockTimeoutMs));\n    assert(enterLockTimeoutMs >= 1000);\n    assert(_.isNumber(inLockTimeoutMs));\n    assert(inLockTimeoutMs >= 1000);\n\n    let self = this;\n    return asyncHelpers.aggressiveRetry(\n        function () {\n            return Bluebird.resolve(self._impl.enterLock(lockName, inLockTimeoutMs));\n        },\n        function (lockInfo) {\n            return !!lockInfo;\n        },\n        enterLockTimeoutMs,\n        function () {\n            return new errors.TimeoutError(\"Entering lock '\" + lockName + \"' has timed out.\");\n        }\n    );\n};\n\nWorkflowPersistence.prototype.renewLock = function (lockId, inLockTimeoutMs) {\n    assert(!!lockId);\n    assert(inLockTimeoutMs > 0);\n\n    return Bluebird.resolve(this._impl.renewLock(lockId, inLockTimeoutMs));\n};\n\nWorkflowPersistence.prototype.exitLock = function (lockId) {\n    assert(!!lockId);\n\n    return Bluebird.resolve(this._impl.exitLock(lockId));\n};\n\nWorkflowPersistence.prototype.isRunning = function (workflowName, instanceId) {\n    assert(_.isString(workflowName));\n    assert(!!instanceId);\n\n    return Bluebird.resolve(this._impl.isRunning(workflowName, instanceId));\n};\n\nWorkflowPersistence.prototype.persistState = function (instance) {\n    assert(instance instanceof WorkflowInstance);\n\n    let data = instance.getStateToPersist();\n    return Bluebird.resolve(this._impl.persistState(data));\n};\n\nWorkflowPersistence.prototype.getRunningInstanceIdHeader = function (workflowName, instanceId) {\n    assert(_.isString(workflowName));\n    assert(!!instanceId);\n\n    return Bluebird.resolve(this._impl.getRunningInstanceIdHeader(workflowName, instanceId));\n};\n\nWorkflowPersistence.prototype.loadState = async(function* (workflowName, instanceId) {\n    assert(_.isString(workflowName));\n    assert(!!instanceId);\n\n    // Without: idleMethods, promotedProperties\n    let state = yield (Bluebird.resolve(this._impl.loadState(workflowName, instanceId)));\n    if (!state) {\n        throw new Error(\"Instance state of workflow '\" + workflowName + \"' by id '\" + instanceId + \"' is not found.\");\n    }\n    return state;\n});\n\nWorkflowPersistence.prototype.removeState = function (workflowName, instanceId, succeeded, error) {\n    assert(_.isString(workflowName));\n    assert(!!instanceId);\n    assert(_.isBoolean(succeeded));\n\n    return Bluebird.resolve(this._impl.removeState(workflowName, instanceId, succeeded, error));\n};\n\nWorkflowPersistence.prototype.loadPromotedProperties = function (workflowName, instanceId) {\n    assert(_.isString(workflowName));\n    assert(!!instanceId);\n\n    return Bluebird.resolve(this._impl.loadPromotedProperties(workflowName, instanceId));\n};\n\nWorkflowPersistence.prototype.getNextWakeupables = function (count) {\n    assert(count > 0);\n\n    return Bluebird.resolve(this._impl.getNextWakeupables(count));\n};\n\nWorkflowPersistence.prototype.getRunningInstanceHeadersForOtherVersion = function(workflowName, version) {\n    assert(_.isString(workflowName));\n    assert(_.isString(version));\n\n    return Bluebird.resolve(this._impl.getRunningInstanceHeadersForOtherVersion(workflowName, version));\n};\n\nmodule.exports = WorkflowPersistence;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/workflowInstance.js":"\"use strict\";\n\nlet Workflow = require(\"../activities/workflow\");\nlet ActivityExecutionContext = require(\"../activities/activityExecutionContext\");\nlet ActivityExecutionEngine = require(\"../activities/activityExecutionEngine\");\nlet BeginMethod = require(\"../activities/beginMethod\");\nlet EndMethod = require(\"../activities/endMethod\");\nlet errors = require(\"../common/errors\");\nlet enums = require(\"../common/enums\");\nlet specStrings = require(\"../common/specStrings\");\nlet _ = require(\"lodash\");\nlet constants = require(\"../common/constants\");\nlet Bluebird = require(\"bluebird\");\nlet is = require(\"../common/is\");\nlet asyncHelpers = require(\"../common/asyncHelpers\");\nlet async = asyncHelpers.async;\nlet EventEmitter = require('events').EventEmitter;\nlet util = require(\"util\");\nlet debug = require(\"debug\")(\"wf4node:WorkflowInstance\");\n\nfunction WorkflowInstance(host) {\n    EventEmitter.call(this);\n\n    this._host = host;\n    this.id = null;\n    this._engine = null;\n    this.createdOn = null;\n    this._beginMethodWithCreateInstCallback = null;\n    this._endMethodCallback = null;\n    this._idleInstanceIdPathCallback = null;\n    this.activeDelays = [];\n    this.workflowVersion = null;\n}\n\nutil.inherits(WorkflowInstance, EventEmitter);\n\nObject.defineProperties(\n    WorkflowInstance.prototype, {\n        execState: {\n            get: function () {\n                return this._engine ? this._engine.execState : null;\n            }\n        },\n        workflowName: {\n            get: function () {\n                return this._engine ? this._engine.rootActivity.name.trim() : null;\n            }\n        },\n        updatedOn: {\n            get: function () {\n                return this._engine ? this._engine.updatedOn : null;\n            }\n        },\n        persistence: {\n            get: function() {\n                return this._host._persistence;\n            }\n        }\n    });\n\nWorkflowInstance.prototype.create = async(function* (execContext, workflowVersion, methodName, args, lockInfo) {\n    let self = this;\n\n    self.setWorkflow(execContext, workflowVersion);\n    self._resetCallbacksAndState();\n\n    let createMethodReached = false;\n    let instanceIdPath = null;\n    self._beginMethodWithCreateInstCallback = function (mn, ip) {\n        if (mn === methodName) {\n            createMethodReached = true;\n            instanceIdPath = ip;\n        }\n    };\n\n    self.createdOn = new Date();\n\n    try {\n        if (self._engine.isIdle(yield self._engine.invoke())) {\n            if (createMethodReached) {\n                self._resetCallbacksAndState();\n\n                if (instanceIdPath) {\n                    if (_.isUndefined(self.id = self._host._instanceIdParser.parse(instanceIdPath, args))) {\n                        throw new errors.WorkflowError(\"Cannot parse BeginMethod's instanceIdPath '\" + instanceIdPath + \"' on arguments of method '\" + methodName + \"'.\");\n                    }\n                    yield (self._enterLockForCreatedInstance(lockInfo));\n                }\n\n                let createEndMethodReached = false;\n                let result;\n                let endInstanceIdPath = null;\n                self._endMethodCallback =\n                    function (mn, ip, r) {\n                        if (mn === methodName) {\n                            createEndMethodReached = true;\n                            endInstanceIdPath = ip;\n                            result = r;\n                        }\n                    };\n\n                let idleMethods = [];\n                self._idleInstanceIdPathCallback =\n                    function (mn, ip) {\n                        idleMethods.push(\n                            {\n                                methodName: mn,\n                                instanceIdPath: ip\n                            });\n                    };\n\n                yield (self._engine.resumeBookmark(specStrings.hosting.createBeginMethodBMName(methodName), enums.activityStates.complete, args));\n\n                if (createEndMethodReached) {\n                    if (_.isUndefined(self.id)) {\n                        if (endInstanceIdPath) {\n                            if (_.isUndefined(self.id = self._host._instanceIdParser.parse(endInstanceIdPath, result))) {\n                                throw new errors.WorkflowError(\"Cannot parse EndMethods's instanceIdPath '\" + instanceIdPath + \"' on arguments of method '\" + methodName + \"'.\");\n                            }\n                            yield self._enterLockForCreatedInstance(lockInfo);\n                        }\n                        else {\n                            throw new errors.WorkflowError(\"BeginMethod or EndMethod of method '\" + methodName + \"' doesn't specify an instanceIdPath property value.\");\n                        }\n                    }\n                }\n                else {\n                    throw new errors.WorkflowError(\"Workflow has been completed or gone to idle without reaching an EndMethod activity of method '\" + methodName + \"'.\");\n                }\n\n                if (self.execState === enums.activityStates.idle) {\n                    if (idleMethods.length === 0) {\n                        throw new errors.WorkflowError(\"Workflow has gone to idle, but there is no active BeginMethod activities to wait for.\");\n                    }\n                }\n                else {\n                    if (idleMethods.length !== 0) {\n                        throw new errors.WorkflowError(\"Workflow has completed, but there is active BeginMethod activities to wait for.\");\n                    }\n                }\n\n                return result;\n            }\n            else {\n                throw new errors.WorkflowError(\"Workflow has gone to idle without reaching an instance creator BeginMethod activity of method '\" + methodName + \"'.\");\n            }\n        }\n        else {\n            throw new errors.WorkflowError(\"Workflow has been completed without reaching an instance creator BeginMethod activity.\");\n        }\n    }\n    catch (e) {\n        debug(\"Create error: %s\", e.stack);\n        if (e instanceof errors.TimeoutError) {\n            throw new errors.MethodIsNotAccessibleError(\"Cannot create instanceof workflow '\" + self.workflowName + \"', because '\" + methodName + \"' is locked.\");\n        }\n        if (e instanceof errors.BookmarkNotFoundError) {\n            throw new errors.MethodIsNotAccessibleError(\"Cannot create instanceof workflow '\" + self.workflowName + \"', because bookmark of '\" + methodName + \"' doesn't exist.\");\n        }\n        throw e;\n    }\n    finally {\n        self._resetCallbacks();\n    }\n});\n\nWorkflowInstance.prototype._enterLockForCreatedInstance = async(\n    function* (lockInfo) {\n        if (lockInfo) {\n            yield this._host._enterLockForCreatedInstance(this, lockInfo);\n        }\n    });\n\nWorkflowInstance.prototype.setWorkflow = function (execContext, workflowVersion, instanceId) {\n    let self = this;\n    if (!(execContext instanceof ActivityExecutionContext)) {\n        throw new TypeError(\"Workflow argument expected.\");\n    }\n    if (!(_.isString(workflowVersion)) || !workflowVersion) {\n        throw new TypeError(\"Workflow version expected.\");\n    }\n    this.workflowVersion = workflowVersion;\n    this._engine = new ActivityExecutionEngine(execContext, this);\n    this._engine.on(\n        enums.events.workflowEvent,\n        function (args) {\n            let arr = _.toArray(args);\n            arr.splice(0, 0, self.instanceId);\n            self.emit(enums.events.workflowEvent, args);\n        });\n    this._addMyTrackers();\n    if (!_.isUndefined(instanceId)) {\n        this.id = instanceId;\n    }\n    this._copyParsFromHost();\n};\n\nWorkflowInstance.prototype.callMethod = async(function* (methodName, args) {\n    let self = this;\n\n    self._resetCallbacksAndState();\n\n    let endMethodReached = false;\n    let result = null;\n    self._endMethodCallback =\n        function (mn, ip, r) {\n            if (mn === methodName) {\n                endMethodReached = true;\n                result = r;\n            }\n        };\n\n    let idleMethods = [];\n    self._idleInstanceIdPathCallback =\n        function (mn, ip) {\n            idleMethods.push(\n                {\n                    methodName: mn,\n                    instanceIdPath: ip\n                });\n        };\n\n    try {\n        yield self._engine.resumeBookmark(specStrings.hosting.createBeginMethodBMName(methodName), enums.activityStates.complete, args);\n\n        if (!endMethodReached) {\n            throw new errors.WorkflowError(\"Workflow has been completed or gone to idle without reaching an EndMethod activity of method name '\" + methodName + \"'.\");\n        }\n\n        if (self.execState === enums.activityStates.idle) {\n            if (idleMethods.length === 0) {\n                throw new errors.WorkflowError(\"Workflow has gone to idle, but there is no active BeginMethod activities to wait for.\");\n            }\n        }\n        else {\n            if (idleMethods.length !== 0) {\n                throw new errors.WorkflowError(\"Workflow has completed, but there is active BeginMethod activities to wait for.\");\n            }\n        }\n\n        return result;\n    }\n    catch (e) {\n        debug(\"Call method error: %s\", e.stack);\n        if (e instanceof errors.BookmarkNotFoundError) {\n            throw new errors.MethodIsNotAccessibleError(\"Cannot call method '\" + methodName + \"' of workflow '\" + self.workflowName + \"', because its bookmark doesn't exist.\");\n        }\n        throw e;\n    }\n    finally {\n        self._resetCallbacks();\n    }\n});\n\nWorkflowInstance.prototype._copyParsFromHost = function () {\n    for (let t of this._host._trackers) {\n        this._engine.addTracker(t);\n    }\n};\n\nWorkflowInstance.prototype._addMyTrackers = function () {\n    this._addBeginMethodWithCreateInstHelperTracker();\n    this._addEndMethodHelperTracker();\n    this._addIdleInstanceIdPathTracker();\n};\n\nWorkflowInstance.prototype._resetCallbacks = function () {\n    this._beginMethodWithCreateInstCallback = null;\n    this._endMethodCallback = null;\n    this._idleInstanceIdPathCallback = null;\n};\n\nWorkflowInstance.prototype._resetCallbacksAndState = function () {\n    this._resetCallbacks();\n    this.activeDelays = [];\n};\n\nWorkflowInstance.prototype._addBeginMethodWithCreateInstHelperTracker = function () {\n    let self = this;\n    let tracker = {\n        activityStateFilter: function (args) {\n            return self._beginMethodWithCreateInstCallback &&\n                args.scope.$activity instanceof BeginMethod &&\n                args.scope.canCreateInstance &&\n                _.isString(args.scope.methodName) &&\n                (!args.scope.instanceIdPath || _.isString(args.scope.instanceIdPath)) &&\n                args.reason === enums.activityStates.idle;\n        },\n        activityStateChanged: function (args) {\n            let methodName = args.scope.methodName.trim();\n            let instanceIdPath = args.scope.instanceIdPath ? args.scope.instanceIdPath.trim() : null;\n            self._beginMethodWithCreateInstCallback(methodName, instanceIdPath);\n        }\n    };\n    self._engine.addTracker(tracker);\n};\n\nWorkflowInstance.prototype._addEndMethodHelperTracker = function () {\n    let self = this;\n    let tracker = {\n        activityStateFilter: function (args) {\n            return self._endMethodCallback &&\n                args.scope.$activity instanceof EndMethod &&\n                _.isString(args.scope.methodName) &&\n                (!args.scope.instanceIdPath || _.isString(args.scope.instanceIdPath)) &&\n                args.reason === enums.activityStates.complete;\n        },\n        activityStateChanged: function (args) {\n            let methodName = args.scope.methodName.trim();\n            let instanceIdPath = args.scope.instanceIdPath ? args.scope.instanceIdPath.trim() : null;\n            self._endMethodCallback(methodName, instanceIdPath, args.result);\n        }\n    };\n    self._engine.addTracker(tracker);\n};\n\nWorkflowInstance.prototype._addIdleInstanceIdPathTracker = function () {\n    let self = this;\n    let tracker = {\n        activityStateFilter: function (args) {\n            return self._idleInstanceIdPathCallback &&\n                args.scope.$activity instanceof BeginMethod &&\n                _.isString(args.scope.methodName) &&\n                _.isString(args.scope.instanceIdPath) &&\n                args.reason === enums.activityStates.idle;\n        },\n        activityStateChanged: function (args) {\n            let methodName = args.scope.methodName.trim();\n            let instanceIdPath = args.scope.instanceIdPath.trim();\n            self._idleInstanceIdPathCallback(methodName, instanceIdPath);\n\n            // This is where a method goes idle.\n            // So if it a DelayTo method, we should remember that.\n            if (specStrings.hosting.isDelayToMethodName(methodName)) {\n                self.activeDelays.push({\n                    methodName: methodName,\n                    delayTo: args.scope.delayTo\n                });\n            }\n        }\n    };\n    self._engine.addTracker(tracker);\n};\n\nWorkflowInstance.prototype.getStateToPersist = function () {\n    let sp = this._engine.getStateAndPromotions(this._host.options.serializer, this._host.options.enablePromotions);\n    return {\n        instanceId: this.id,\n        createdOn: this.createdOn,\n        workflowName: this.workflowName,\n        workflowVersion: this.workflowVersion,\n        updatedOn: this._engine.updatedOn,\n        state: sp.state,\n        promotedProperties: sp.promotedProperties,\n        activeDelays: this.activeDelays\n    };\n};\n\nWorkflowInstance.prototype.restoreState = function (json) {\n    if (!_.isObject(json)) {\n        throw new TypeError(\"Argument 'json' is not an object.\");\n    }\n    if (json.instanceId !== this.id) {\n        throw new Error(\"State instanceId property value of '\" + json.instanceId + \"' is different than the current instance id '\" + this.id + \"'.\");\n    }\n    if (json.workflowName !== this.workflowName) {\n        throw new Error(\"State workflowName property value of '\" + json.workflowName + \"' is different than the current Workflow name '\" + this.workflowName + \"'.\");\n    }\n    if (json.workflowVersion !== this.workflowVersion) {\n        throw new Error(\"State workflowVersion property value of '\" + json.workflowVersion + \"' is different than the current Workflow version '\" + this.workflowVersion + \"'.\");\n    }\n    if (!_.isDate(json.createdOn)) {\n        throw new Error(\"State createdOn property value of '\" + json.createdOn + \"' is not a Date.\");\n    }\n\n    this.createdOn = json.createdOn;\n    this._engine.setState(this._host.options.serializer, json.state);\n};\n\nWorkflowInstance.prototype.addTracker = function(tracker) {\n    this._engine.addTracker(tracker);\n};\n\nmodule.exports = WorkflowInstance;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/knownInstaStore.js":"\"use strict\";\n\nlet specStrings = require(\"../common/specStrings\");\nlet InstIdPaths = require(\"./instIdPaths\");\nlet _ = require(\"lodash\");\nlet debug = require(\"debug\")(\"wf4node:KnownInstaStore\");\nlet enums = require(\"../common/enums\");\n\nfunction KnownInstaStore() {\n    this._instances = new Map();\n}\n\nKnownInstaStore.prototype.add = function (workflowName, insta) {\n    this._instances.set(specStrings.hosting.doubleKeys(workflowName, insta.id), insta);\n};\n\nKnownInstaStore.prototype.get = function (workflowName, instanceId) {\n    return this._instances.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nKnownInstaStore.prototype.exists = function (workflowName, instanceId) {\n    return this._instances.has(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nKnownInstaStore.prototype.remove = function (workflowName, instanceId) {\n    this._instances.delete(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nKnownInstaStore.prototype.getNextWakeupables = function (count) {\n    let now = new Date();\n    let result = [];\n    for (let insta of this._instances.values()) {\n        if (insta.execState === enums.activityStates.idle && insta.activeDelays) {\n            for (let ad of insta.activeDelays) {\n                if (ad.delayTo <= now) {\n                    result.push({\n                        instanceId: insta.id,\n                        workflowName: insta.workflowName,\n                        activeDelay: {\n                            methodName: ad.methodName,\n                            delayTo: ad.delayTo\n                        }\n                    });\n                }\n            }\n        }\n    }\n    result.sort(function (i1, i2) {\n        if (i1.updatedOn < i2.updatedOn) {\n            return -1;\n        }\n        else if (i1.updatedOn > i2.updatedOn) {\n            return 1;\n        }\n        else if (i1.activeDelay.delayTo < i2.activeDelay.delayTo) {\n            return -1;\n        }\n        else if (i1.activeDelay.delayTo > i2.activeDelay.delayTo) {\n            return 1;\n        }\n        return 0;\n    });\n    return _.take(result, count);\n};\n\nKnownInstaStore.prototype.getRunningInstanceHeadersForOtherVersion = function(workflowName, version) {\n    let result = [];\n    for (let insta of this._instances.values()) {\n        if (insta.workflowName === workflowName && insta.version !== version) {\n            result.push({\n                workflowName: insta.workflowName,\n                workflowVersion: insta.workflowVersion,\n                instanceId: insta.id\n            });\n        }\n    }\n    return result;\n};\n\nKnownInstaStore.prototype.addTracker = function(tracker) {\n    for (let insta of this._instances.values()) {\n        insta.addTracker(tracker);\n    }\n};\n\nmodule.exports = KnownInstaStore;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/instIdPaths.js":"\"use strict\";\n\nlet specStrings = require(\"../common/specStrings\");\nlet is = require(\"../common/is\");\n\nfunction InstIdPaths() {\n    this._map = new Map();\n}\n\nInstIdPaths.prototype.add = function (workflowName, methodName, instanceIdPath) {\n    let key = specStrings.hosting.doubleKeys(workflowName, methodName);\n    let inner = this._map.get(key);\n    if (!inner) {\n        inner = new Map();\n        this._map.set(key, inner);\n    }\n    let count = inner.get(instanceIdPath) || 0;\n    inner.set(instanceIdPath, count + 1);\n};\n\nInstIdPaths.prototype.remove = function (workflowName, methodName, instanceIdPath) {\n    let key = specStrings.hosting.doubleKeys(workflowName, methodName);\n    let inner = this._map.get(key);\n    if (inner) {\n        let count = inner.get(instanceIdPath);\n        if (!_.isUndefined(count)) {\n            if (count === 1) {\n                this._map.delete(key);\n            }\n            else {\n                inner.set(instanceIdPath, count - 1);\n            }\n        }\n    }\n    return false;\n};\n\nInstIdPaths.prototype.items = function* (workflowName, methodName) {\n    let key = specStrings.hosting.doubleKeys(workflowName, methodName);\n    let inner = this._map.get(key);\n    if (inner) {\n        for (let ik of inner.keys()) {\n            yield ik;\n        }\n    }\n};\n\nmodule.exports = InstIdPaths;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/keepLockAlive.js":"var KeepAlive = require(\"./keepAlive\");\nvar util = require(\"util\");\nvar Bluebird = require(\"bluebird\");\n\nfunction KeepLockAlive(persistence, lockInfo, inLockTimeout, renewPeriod) {\n    var self = this;\n    KeepAlive.call(\n        self,\n        function () {\n            if (lockInfo && lockInfo.id) return persistence.renewLock(lockInfo.id, inLockTimeout); else return Bluebird.resolve(0);\n        },\n        renewPeriod);\n}\n\nutil.inherits(KeepLockAlive, KeepAlive);\n\nmodule.exports = KeepLockAlive;\n","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/keepAlive.js":"var _ = require(\"lodash\");\nvar Bluebird = require(\"bluebird\");\n\nfunction KeepAlive(repeatFunc, repeatPeriod) {\n    if (!_.isFunction(repeatFunc)) throw new TypeError(\"Function argument expected.\");\n    this._repeatFunc = repeatFunc;\n    this._repeatPeriod = repeatPeriod;\n    this._isRunning = true;\n    this._toId = null;\n    var self = this;\n    process.nextTick(function () {\n        self._start.call(self);\n    });\n}\n\nKeepAlive.prototype._start = function () {\n    var self = this;\n    self._toId = setTimeout(\n        function () {\n            if (self._isRunning) {\n                Bluebird.resolve(self._repeatFunc())\n                    .catch(function (e) {\n                        console.error(\"Keep alive failed:\\n\" + e.stack);\n                    })\n                    .finally(function () {\n                        if (self._isRunning) self._start();\n                    });\n            }\n        },\n        self._repeatPeriod);\n}\n\nKeepAlive.prototype.end = function () {\n    if (!this._isRunning) throw new Error(\"Keep alive has already ended.\");\n\n    this._isRunning = false;\n    if (this._toId) clearTimeout(this._toId);\n}\n\nmodule.exports = KeepAlive;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/wakeUp.js":"\"use strict\";\n\nlet EventEmitter = require(\"events\").EventEmitter;\nlet Bluebird = require(\"bluebird\");\nlet async = require(\"../common\").asyncHelpers.async;\nlet debug = require(\"debug\")(\"wf4node:WakeUp\");\nlet util = require(\"util\");\n\nfunction WakeUp(knownInstaStore, persistence, options) {\n    EventEmitter.call(this);\n\n    this.knownInstaStore = knownInstaStore;\n    this.persistence = persistence;\n    this.options = options || {};\n    this._working = false;\n    this._timeout = null;\n    this._batchSize = this.options.batchSize || 10;\n}\n\nutil.inherits(WakeUp, EventEmitter);\n\nWakeUp.prototype.start = function () {\n    if (!this._timeout) {\n        debug(\"Start.\");\n        let self = this;\n        this._timeout = setTimeout(function () { self._step(); }, this.options.interval || 5000);\n    }\n};\n\nWakeUp.prototype.stop = function () {\n    if (this._timeout) {\n        debug(\"Stop.\");\n        clearTimeout(this._timeout);\n        this._timeout = null;\n    }\n};\n\nWakeUp.prototype._step = async(function*() {\n    let self = this;\n    try {\n        if (this._working) {\n            debug(\"Skipping current step because work in progress.\");\n            return;\n        }\n        debug(\"Starting next step.\");\n        this._working = true;\n        try {\n            let wakeupables = yield this._getNextWakeupables();\n            if (wakeupables && wakeupables.length) {\n                debug(\"%d selected to wake up.\", wakeupables.length);\n                let tasks = [];\n                let count = 0;\n                for (let wakeupable of wakeupables) {\n                    tasks.push(async(function*() {\n                        if (count >= self._batchSize) {\n                            return;\n                        }\n                        debug(\"Waking up workflow %s, id: %s\", wakeupable.workflowName, wakeupable.instanceId);\n                        wakeupable.result = {};\n                        let promise = new Bluebird(function (resolve, reject) {\n                            wakeupable.result.resolve = resolve;\n                            wakeupable.result.reject = reject;\n                        });\n                        self.emit(\"continue\", wakeupable);\n                        try {\n                            yield promise;\n                            count++;\n                            debug(\"Processing delay completed.\");\n                        }\n                        catch (e) {\n                            debug(\"Processing delay error: %s\", e.stack);\n                            self.emit(\"error\", e);\n                        }\n                    })());\n                }\n\n                let results = yield Bluebird.settle(tasks);\n                for (let result of results) {\n                    if (result.isRejected()) {\n                        throw result.reason();\n                    }\n                }\n            }\n            else {\n                debug(\"There is no instance to wake up.\");\n            }\n        }\n        catch (e) {\n            this.emit(\"error\", e);\n        }\n        finally {\n            debug(\"Next step completed.\");\n            this._working = false;\n        }\n    }\n    finally {\n        if (this._timeout) {\n            this._timeout = setTimeout(function () { self._step(); }, this.options.interval || 5000);\n        }\n    }\n});\n\nWakeUp.prototype._getNextWakeupables = async(function* () {\n    if (this.persistence) {\n        return yield this.persistence.getNextWakeupables(this._batchSize * 1.5);\n    }\n    else {\n        return this.knownInstaStore.getNextWakeupables(this._batchSize * 1.5);\n    }\n});\n\nmodule.exports = WakeUp;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/lib/es6/hosting/memoryPersistence.js":"\"use strict\";\n\nlet uuid = require('node-uuid');\nrequire('date-utils');\nlet specStrings = require(\"../common/specStrings\");\nlet InstIdPaths = require(\"./instIdPaths\");\nlet is = require(\"../common/is\");\nlet _ = require(\"lodash\");\nlet debug = require(\"debug\")(\"wf4node:MemoryPersistence\");\nlet errors = require(\"../common/errors\");\n\nfunction MemoryPersistence() {\n    this._instanceData = new Map();\n    this._locksById = new Map();\n    this._locksByName = new Map();\n}\n\nMemoryPersistence.prototype.clear = function () {\n    this._instanceData.clear();\n    this._locksById.clear();\n    this._locksByName.clear();\n};\n\nMemoryPersistence.prototype.enterLock = function (lockName, inLockTimeoutMs) {\n    debug(\"enterLock(%s, %d)\", lockName, inLockTimeoutMs);\n\n    let now = new Date();\n    debug(\"Searching for lock by name %s\", lockName);\n    let cLock = this._locksByName.get(lockName);\n    debug(\"Lock info: %j\", cLock);\n    if (!cLock || cLock.heldTo.getTime() < now.getTime()) {\n        let lockInfo = {\n            id: uuid.v4(),\n            name: lockName,\n            heldTo: now.addMilliseconds(inLockTimeoutMs)\n        };\n\n        this._locksById.set(lockInfo.id, lockInfo);\n        this._locksByName.set(lockInfo.name, lockInfo);\n\n        debug(\"LOCKED: %s\", lockInfo.name);\n\n        return lockInfo;\n    }\n    debug(\"It is already held.\");\n    return null;\n};\n\nMemoryPersistence.prototype.renewLock = function (lockId, inLockTimeoutMs) {\n    debug(\"renewLock(%s, %d)\", lockId, inLockTimeoutMs);\n\n    let cLock = this._getLockById(lockId);\n    cLock.heldTo = new Date().addMilliseconds(inLockTimeoutMs);\n    debug(\"Lock %s extended to %s\", lockId, cLock.heldTo);\n};\n\nMemoryPersistence.prototype.exitLock = function (lockId) {\n    debug(\"exitLock(%s)\", lockId);\n\n    let cLock = this._getLockById(lockId);\n    this._locksById.delete(cLock.id);\n    this._locksByName.delete(cLock.name);\n\n    debug(\"UNLOCKED: %s\", cLock.name);\n};\n\nMemoryPersistence.prototype._getLockById = function (lockId) {\n    let cLock = this._locksById.get(lockId);\n    let now = new Date();\n    if (!cLock || now.compareTo(cLock.heldTo) > 0) {\n        throw new Error(\"Lock by id '\" + lockId + \"' doesn't exists.\");\n    }\n    return cLock;\n};\n\nMemoryPersistence.prototype.isRunning = function (workflowName, instanceId) {\n    debug(\"isRunning(%s, %s)\", workflowName, instanceId);\n\n    return this._instanceData.has(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nMemoryPersistence.prototype.persistState = function (state) {\n    debug(\"persistState(%j)\", state);\n\n    state = _.clone(state);\n    state.state = JSON.stringify(state.state);\n\n    this._instanceData.set(specStrings.hosting.doubleKeys(state.workflowName, state.instanceId), state);\n};\n\nMemoryPersistence.prototype.getRunningInstanceIdHeader = function (workflowName, instanceId) {\n    debug(\"getRunningInstanceIdHeader(%s, %s)\", workflowName, instanceId);\n\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n    if (!state) {\n        return null;\n    }\n    return {\n        updatedOn: state.updatedOn,\n        workflowName: state.workflowName,\n        workflowVersion: state.workflowVersion,\n        instanceId: state.instanceId\n    };\n};\n\nMemoryPersistence.prototype.loadState = function (workflowName, instanceId) {\n    debug(\"loadState(%s, %s)\", workflowName, instanceId);\n\n    let state = this._loadState(workflowName, instanceId);\n    state = _.clone(state);\n    state.state = JSON.parse(state.state);\n    return state;\n};\n\nMemoryPersistence.prototype.removeState = function (workflowName, instanceId) {\n    debug(\"removeState(%s, %s)\", workflowName, instanceId);\n\n    this._instanceData.delete(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nMemoryPersistence.prototype._loadState = function (workflowName, instanceId) {\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n    if (!state) {\n        throw new errors.WorkflowNotFoundError(\"Instance data of workflow '\" + workflowName + \"' by id '\" + instanceId + \"' is not found.\");\n    }\n    return state;\n};\n\nMemoryPersistence.prototype.loadPromotedProperties = function (workflowName, instanceId) {\n    debug(\"loadPromotedProperties(%s, %s)\", workflowName, instanceId);\n\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n    return state ? state.promotedProperties : null;\n};\n\nMemoryPersistence.prototype.getNextWakeupables = function (count) {\n    debug(\"getNextWakeupables(%d)\", count);\n\n    let now = new Date();\n    let result = [];\n    for (let data of this._instanceData.values()) {\n        if (data.activeDelays) {\n            for (let ad of data.activeDelays) {\n                if (ad.delayTo <= now) {\n                    result.push({\n                        instanceId: data.instanceId,\n                        workflowName: data.workflowName,\n                        updatedOn: data.updatedOn,\n                        activeDelay: {\n                            methodName: ad.methodName,\n                            delayTo: ad.delayTo\n                        }\n                    });\n                }\n            }\n        }\n    }\n    result.sort(function (i1, i2) {\n        if (i1.updatedOn < i2.updatedOn) {\n            return -1;\n        }\n        else if (i1.updatedOn > i2.updatedOn) {\n            return 1;\n        }\n        else if (i1.activeDelay.delayTo < i2.activeDelay.delayTo) {\n            return -1;\n        }\n        else if (i1.activeDelay.delayTo > i2.activeDelay.delayTo) {\n            return 1;\n        }\n        return 0;\n    });\n    return _.take(result, count);\n};\n\nMemoryPersistence.prototype.getRunningInstanceHeadersForOtherVersion = function (workflowName, version) {\n    let result = [];\n    for (let data of this._instanceData.values()) {\n        if (data.workflowName === workflowName && data.version !== version) {\n            result.push({\n                workflowName: data.workflowName,\n                workflowVersion: data.workflowVersion,\n                instanceId: data.instanceId\n            });\n        }\n    }\n    return result;\n};\n\nmodule.exports = MemoryPersistence;","/home/travis/build/npmtest/node-npmtest-workflow-4-node/node_modules/workflow-4-node/gulpfile.js":"\"use strict\";\nlet gulp = require(\"gulp\");\nlet babel = require(\"gulp-babel\");\nlet gulpSequence = require(\"gulp-sequence\");\nlet exec = require(\"child_process\").exec;\nlet sourcemaps = require(\"gulp-sourcemaps\");\n\ngulp.task(\"compile-test\", function () {\n    return gulp.src(\"tests/es6/**/*.js\", {base: \"tests/es6\"})\n        .pipe(sourcemaps.init())\n        .pipe(babel({\n            presets: [\"es2015\"]\n        }))\n        .pipe(sourcemaps.write(\".\"))\n        .pipe(gulp.dest(\"tests/es5\"));\n});\n\ngulp.task(\"compile-lib\", function () {\n    return gulp.src(\"lib/es6/**/*.js\", {base: \"lib/es6\"})\n        .pipe(sourcemaps.init())\n        .pipe(babel({\n            presets: [\"es2015\"]\n        }))\n        .pipe(sourcemaps.write(\".\"))\n        .pipe(gulp.dest(\"lib/es5\"));\n});\n\ngulp.task(\"compile\", gulpSequence([\"compile-test\", \"compile-lib\"]));\n\ngulp.task(\"default\", gulpSequence(\"compile\"));\n\ngulp.task(\"npm-publish\", function (done) {\n    exec(\"npm publish\").on(\"close\", function(e) {\n        if (e) {\n            done(new Error(\"Cannot publish to the npm. Exit code: \" + e + \".\"));\n        }\n        else {\n            done();\n        }\n    });\n});\n\ngulp.task(\"publish\", gulpSequence(\"compile\", \"npm-publish\")); "}